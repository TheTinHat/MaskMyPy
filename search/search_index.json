{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python tools for anonymizing geographic data. Introduction \u00b6 MaskMyPy is a Python package that performs geographic masking on GeoDataFrames . It offers two main methods: donut masking and street masking . MaskMyPy also supports calculating metrics to help optimize and validate masking parameters. Currently, it offers k-anonymity estimation using population data, k-anonymity calculation using address data, and displacement distance calculation between sensitive and masked points. Disclaimer : MaskMyPy is offered as-is, without warranty of any kind. Geographic masking is a hard problem that requires informed decisions and validation. MaskMyPy provides helpful tools for geographic masking, but does not replace expertise. Installation \u00b6 pip install maskmypy Example \u00b6 The following snippet applies a 500 meter donut mask to a GeoDataFrame of sensitive (e.g. secret) points: >>> from maskmypy import Donut >>> import geopandas as gpd >>> secret = gpd . read_file ( 'secret_points' ) >>> secret . head () CID geometry 0 1 POINT ( - 13703523.337 6313860.932 ) 1 2 POINT ( - 13703436.959 6314112.457 ) 2 3 POINT ( - 13703679.041 6314040.923 ) 3 4 POINT ( - 13703285.553 6313721.356 ) 4 5 POINT ( - 13703200.338 6313847.431 ) >>> masked_points = Donut ( secret , max_distance = 500 ) . run () >>> masked_points . head () CID geometry 0 1 POINT ( - 13703383.941 6313989.161 ) 1 2 POINT ( - 13703227.863 6313973.121 ) 2 3 POINT ( - 13703313.001 6314172.582 ) 3 4 POINT ( - 13703107.232 6313614.978 ) 4 5 POINT ( - 13702837.385 6314140.874 ) Unless specified, MaskMyPy uses the same units of distance as the CRS of the input secret points. If our secret points instead used a CRS that is in feet, then our mask would have had a maximum distance of 500 feet. We can also add some parameters to the .run() method to help us better evaluate our mask. For instance, we can visually inspect the masking process by creating a map of displacement distances like so: >>> masked_points = Donut ( secret , max_distance = 500 ) . run ( map_displacement = True ) Alternatively, we could add a context layer of address points and use it to calculate the k-anonymity of each masked point: >>> address_points = gpd . read_file ( 'addresses.shp' ) >>> masked_points = Donut ( secret , max_distance = 500 , address = address_points ) . run ( calculate_k = True ) >>> masked_points . head () CID geometry k_calc 0 1 POINT ( - 13703383.941 6313989.161 ) 19 1 2 POINT ( - 13703227.863 6313973.121 ) 15 2 3 POINT ( - 13703313.001 6314172.582 ) 43 3 4 POINT ( - 13703107.232 6313614.978 ) 23 4 5 POINT ( - 13702837.385 6314140.874 ) 51 See here to find other useful .run() parameters. Roadmap \u00b6 The following features are currently planned: Location Swapping/Verified Neighbor masks Mask metadata export","title":"Home"},{"location":"#introduction","text":"MaskMyPy is a Python package that performs geographic masking on GeoDataFrames . It offers two main methods: donut masking and street masking . MaskMyPy also supports calculating metrics to help optimize and validate masking parameters. Currently, it offers k-anonymity estimation using population data, k-anonymity calculation using address data, and displacement distance calculation between sensitive and masked points. Disclaimer : MaskMyPy is offered as-is, without warranty of any kind. Geographic masking is a hard problem that requires informed decisions and validation. MaskMyPy provides helpful tools for geographic masking, but does not replace expertise.","title":"Introduction"},{"location":"#installation","text":"pip install maskmypy","title":"Installation"},{"location":"#example","text":"The following snippet applies a 500 meter donut mask to a GeoDataFrame of sensitive (e.g. secret) points: >>> from maskmypy import Donut >>> import geopandas as gpd >>> secret = gpd . read_file ( 'secret_points' ) >>> secret . head () CID geometry 0 1 POINT ( - 13703523.337 6313860.932 ) 1 2 POINT ( - 13703436.959 6314112.457 ) 2 3 POINT ( - 13703679.041 6314040.923 ) 3 4 POINT ( - 13703285.553 6313721.356 ) 4 5 POINT ( - 13703200.338 6313847.431 ) >>> masked_points = Donut ( secret , max_distance = 500 ) . run () >>> masked_points . head () CID geometry 0 1 POINT ( - 13703383.941 6313989.161 ) 1 2 POINT ( - 13703227.863 6313973.121 ) 2 3 POINT ( - 13703313.001 6314172.582 ) 3 4 POINT ( - 13703107.232 6313614.978 ) 4 5 POINT ( - 13702837.385 6314140.874 ) Unless specified, MaskMyPy uses the same units of distance as the CRS of the input secret points. If our secret points instead used a CRS that is in feet, then our mask would have had a maximum distance of 500 feet. We can also add some parameters to the .run() method to help us better evaluate our mask. For instance, we can visually inspect the masking process by creating a map of displacement distances like so: >>> masked_points = Donut ( secret , max_distance = 500 ) . run ( map_displacement = True ) Alternatively, we could add a context layer of address points and use it to calculate the k-anonymity of each masked point: >>> address_points = gpd . read_file ( 'addresses.shp' ) >>> masked_points = Donut ( secret , max_distance = 500 , address = address_points ) . run ( calculate_k = True ) >>> masked_points . head () CID geometry k_calc 0 1 POINT ( - 13703383.941 6313989.161 ) 19 1 2 POINT ( - 13703227.863 6313973.121 ) 15 2 3 POINT ( - 13703313.001 6314172.582 ) 43 3 4 POINT ( - 13703107.232 6313614.978 ) 23 4 5 POINT ( - 13702837.385 6314140.874 ) 51 See here to find other useful .run() parameters.","title":"Example"},{"location":"#roadmap","text":"The following features are currently planned: Location Swapping/Verified Neighbor masks Mask metadata export","title":"Roadmap"},{"location":"api_reference/","text":"Masking Classes \u00b6 Every available mask inherits from the maskmypy.mask.Mask class. To reduce a huge amount of duplicated documentation, only new parameters are described in child classes. Refer to the parent class for a full list of parameters. maskmypy . mask . Mask ( secret , population = None , pop_col = 'pop' , container = None , address = None , padding = None , max_tries = 1000 , seed = None ) \u00b6 A base class that all masks inherit from. Do not use this class for masking. Parameters: Name Type Description Default secret GeoDataFrame Secret layer of points that require anonymization. All other GeoDataFrame inputs must match the CRS of the secret point layer. required padding int , float , optional Context layers (e.g. population, address, container, street network) are automatically cropped to the extent of the secret layer, plus some amount of padding to reduce edge effects. By default, padding is set to one fifth the x or y extent, whichever is larger. This parameter allows you to instead specify an exact amount of padding to be added. Recommended if the extent of the secret layer is either very small or very large. Units should match that of the secret layer's CRS. None max_tries int , optional The maximum number of times that MaskMyPy should re-mask a point until it is contained within the corresponding polygon (see container parameter). 1000 seed int , optional Used to seed the random number generator so that masks are reproducible. In other words, given a certain seed, MaskMyPy will always mask data the exact same way. If left unspecified, a seed is randomly selected using SystemRandom None population GeoDataFrame , optional A polygon layer with a column describing population count. None pop_col str , optional The name of the population count column in the population polygon layer. 'pop' container GeoDataFrame , optional A layer containing polygons within which intersecting secret points should remain after masking. This works by masking a point, checking if it intersects the same polygon prior to masking, and retrying until it does. The number of attempts is controlled by the max_tries parameter. Useful for preserving statistical values, such as from census tracts, or to ensure that points are not displaced into impossible locations, such as the ocean. None address GeoDataFrame , optional A layer containing address points. None run ( displacement = False , estimate_k = False , calculate_k = False , map_displacement = False ) \u00b6 Run the masking procedure to anonymize secret points. Parameters: Name Type Description Default displacement bool , optional If True , add a distance column containing the displacement distance. False estimate_k bool , optional If True , estimate the k-anonymity of each anonymized point based on surrounding population density. Requires a population layer to be loaded into the masking object. False calculate_k bool , optional If True , calculate the k-anonymity of each anonymized point based on nearby address points. Requires an address layer to be loaded into the masking class. False map_displacement bool , optional If True , output a file called displacement_map.png that visualizes displacement distance between secret and masked points. False Returns: Type Description GeoDataFrame A GeoDataFrame of anonymized points. maskmypy . Donut ( * args , min_distance = 50 , max_distance = 500 , distribution = 'uniform' , ** kwargs ) \u00b6 Bases: Mask Constructs a donut masking class that (when run) anonymizes points by randomly displacing them between a minimum and maximum distance. Parameters: Name Type Description Default min_distance int , float The minimum distance that points should be displaced. 50 max_distance int , float The maximum distance that points should be displaced. 500 distribution str , optional The distribution used to determine masking distances. The default uniform provides a flat distribution where any value between the minimum and maximum distance is equally likely to be selected. The areal distribution is more likely to select distances that are further away. The gaussian distribution uses a normal distribution, where values towards the middle of the range are most likely to be selected. Note that gaussian distribution has a small chance of selecting values beyond the defined minimum and maximum. 'uniform' maskmypy . Donut_Multiply ( * args , population_multiplier = 5 , ** kwargs ) \u00b6 Bases: Donut Constructs a masking class that (when run) anonymizes points by randomly displacing them according to a minimum and maximum distance, but with an additional multiplier to help take population density into account. Points in the most population-dense areas will have their minimum and maximum masking distances multiplied by 1. This multiplier will increase linearly as population density decreases, with points in the least population-dense areas having their minimum and maximum masking distances multiplied by the full population_mulitplier value. Requires a population layer. Parameters: Name Type Description Default population_multiplier int , float The maximum possible multiplier used to extend masking distances according to population density. 5 maskmypy . Donut_K ( * args , min_k , max_k , ** kwargs ) \u00b6 Bases: Donut Constructs a masking class that (when run) anonymizes points by randomly displacing them according to a desired k-anonymity range. Note that the k-anonymity values only reflect the population density at the point location itself, and do not take into account any surrounding area. This is in contrast to the estimate_k tool, which will actually disaggregate nearby population polygons to construct a more accurate estimate of k-anonymity. Requires a population layer. Parameters: Name Type Description Default min_k int The minimum desired k-anonymity for each point. Please read description above to learn the limitations of this calculation. required max_k int The maximum desired k-anonymity for each point. Please read description above to learn the limitations of this calculation. required maskmypy . Street ( * args , min_depth = 18 , max_depth = 20 , max_length = 500 , ** kwargs ) \u00b6 Bases: Mask Constructs a street masking class that (when run) anonymizes points by randomly displacing them based on the surrounding street network using OpenStreetMap. Does not support containment. Parameters: Name Type Description Default min_depth int , optional The minimum number of nodes to traverse along the street network. Default: 18 18 max_depth int , optional The maximum number of nodes to traverse along the street network. Default: 20 20 max_length int , float , optional Sets a limit for street length, such that any street segments longer than this value will be ignored. Useful for ignoring very long streets that would skew the results, such as highways. 500 Tools \u00b6 MaskMyPy offers several tools for evaluating geographic masks, even if they were not performed by MaskMyPy. maskmypy . tools . displacement ( secret , mask , colname = '_distance' ) \u00b6 Calculates the displacement distance between secret and masked points. Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required colname str , optional Name for the output displacement distance column, by default \"_distance\" '_distance' Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing displacement distances maskmypy . tools . estimate_k ( secret , mask , population , pop_col = 'pop' ) \u00b6 Estimate the k-anonymity of each anonymized point based on surrounding population density. Typically less accurate the calculate_k . Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required population GeoDataFrame A polygon layer with a column describing population count. required pop_col str , optional The name of the population count column in the population polygon layer. 'pop' Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing k-anonymity. maskmypy . tools . calculate_k ( secret , mask , address ) \u00b6 Calculate the k-anonymity of each anonymized point based on surrounding address points. Typically more accurate the estimate_k . Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required address GeoDataFrame , optional A layer containing address points. required Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing k-anonymity. maskmypy . tools . map_displacement ( secret , mask , filename = None , address = None ) \u00b6 Creates a map visualizing the displacement of each point between its original and masked location. Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required filename str , optional If specified, saves the output map to a file. None address GeoDataFrame , optional A layer containing address points. None Returns: Type Description matplotlib . pyplot . plt A plot depicting secret and masked points connected by lines.","title":"API Reference"},{"location":"api_reference/#masking-classes","text":"Every available mask inherits from the maskmypy.mask.Mask class. To reduce a huge amount of duplicated documentation, only new parameters are described in child classes. Refer to the parent class for a full list of parameters.","title":"Masking Classes"},{"location":"api_reference/#maskmypy.mask.Mask","text":"A base class that all masks inherit from. Do not use this class for masking. Parameters: Name Type Description Default secret GeoDataFrame Secret layer of points that require anonymization. All other GeoDataFrame inputs must match the CRS of the secret point layer. required padding int , float , optional Context layers (e.g. population, address, container, street network) are automatically cropped to the extent of the secret layer, plus some amount of padding to reduce edge effects. By default, padding is set to one fifth the x or y extent, whichever is larger. This parameter allows you to instead specify an exact amount of padding to be added. Recommended if the extent of the secret layer is either very small or very large. Units should match that of the secret layer's CRS. None max_tries int , optional The maximum number of times that MaskMyPy should re-mask a point until it is contained within the corresponding polygon (see container parameter). 1000 seed int , optional Used to seed the random number generator so that masks are reproducible. In other words, given a certain seed, MaskMyPy will always mask data the exact same way. If left unspecified, a seed is randomly selected using SystemRandom None population GeoDataFrame , optional A polygon layer with a column describing population count. None pop_col str , optional The name of the population count column in the population polygon layer. 'pop' container GeoDataFrame , optional A layer containing polygons within which intersecting secret points should remain after masking. This works by masking a point, checking if it intersects the same polygon prior to masking, and retrying until it does. The number of attempts is controlled by the max_tries parameter. Useful for preserving statistical values, such as from census tracts, or to ensure that points are not displaced into impossible locations, such as the ocean. None address GeoDataFrame , optional A layer containing address points. None","title":"Mask"},{"location":"api_reference/#maskmypy.mask.Mask.run","text":"Run the masking procedure to anonymize secret points. Parameters: Name Type Description Default displacement bool , optional If True , add a distance column containing the displacement distance. False estimate_k bool , optional If True , estimate the k-anonymity of each anonymized point based on surrounding population density. Requires a population layer to be loaded into the masking object. False calculate_k bool , optional If True , calculate the k-anonymity of each anonymized point based on nearby address points. Requires an address layer to be loaded into the masking class. False map_displacement bool , optional If True , output a file called displacement_map.png that visualizes displacement distance between secret and masked points. False Returns: Type Description GeoDataFrame A GeoDataFrame of anonymized points.","title":"run()"},{"location":"api_reference/#maskmypy.Donut","text":"Bases: Mask Constructs a donut masking class that (when run) anonymizes points by randomly displacing them between a minimum and maximum distance. Parameters: Name Type Description Default min_distance int , float The minimum distance that points should be displaced. 50 max_distance int , float The maximum distance that points should be displaced. 500 distribution str , optional The distribution used to determine masking distances. The default uniform provides a flat distribution where any value between the minimum and maximum distance is equally likely to be selected. The areal distribution is more likely to select distances that are further away. The gaussian distribution uses a normal distribution, where values towards the middle of the range are most likely to be selected. Note that gaussian distribution has a small chance of selecting values beyond the defined minimum and maximum. 'uniform'","title":"Donut"},{"location":"api_reference/#maskmypy.Donut_Multiply","text":"Bases: Donut Constructs a masking class that (when run) anonymizes points by randomly displacing them according to a minimum and maximum distance, but with an additional multiplier to help take population density into account. Points in the most population-dense areas will have their minimum and maximum masking distances multiplied by 1. This multiplier will increase linearly as population density decreases, with points in the least population-dense areas having their minimum and maximum masking distances multiplied by the full population_mulitplier value. Requires a population layer. Parameters: Name Type Description Default population_multiplier int , float The maximum possible multiplier used to extend masking distances according to population density. 5","title":"Donut_Multiply"},{"location":"api_reference/#maskmypy.Donut_K","text":"Bases: Donut Constructs a masking class that (when run) anonymizes points by randomly displacing them according to a desired k-anonymity range. Note that the k-anonymity values only reflect the population density at the point location itself, and do not take into account any surrounding area. This is in contrast to the estimate_k tool, which will actually disaggregate nearby population polygons to construct a more accurate estimate of k-anonymity. Requires a population layer. Parameters: Name Type Description Default min_k int The minimum desired k-anonymity for each point. Please read description above to learn the limitations of this calculation. required max_k int The maximum desired k-anonymity for each point. Please read description above to learn the limitations of this calculation. required","title":"Donut_K"},{"location":"api_reference/#maskmypy.Street","text":"Bases: Mask Constructs a street masking class that (when run) anonymizes points by randomly displacing them based on the surrounding street network using OpenStreetMap. Does not support containment. Parameters: Name Type Description Default min_depth int , optional The minimum number of nodes to traverse along the street network. Default: 18 18 max_depth int , optional The maximum number of nodes to traverse along the street network. Default: 20 20 max_length int , float , optional Sets a limit for street length, such that any street segments longer than this value will be ignored. Useful for ignoring very long streets that would skew the results, such as highways. 500","title":"Street"},{"location":"api_reference/#tools","text":"MaskMyPy offers several tools for evaluating geographic masks, even if they were not performed by MaskMyPy.","title":"Tools"},{"location":"api_reference/#maskmypy.tools.displacement","text":"Calculates the displacement distance between secret and masked points. Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required colname str , optional Name for the output displacement distance column, by default \"_distance\" '_distance' Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing displacement distances","title":"displacement()"},{"location":"api_reference/#maskmypy.tools.estimate_k","text":"Estimate the k-anonymity of each anonymized point based on surrounding population density. Typically less accurate the calculate_k . Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required population GeoDataFrame A polygon layer with a column describing population count. required pop_col str , optional The name of the population count column in the population polygon layer. 'pop' Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing k-anonymity.","title":"estimate_k()"},{"location":"api_reference/#maskmypy.tools.calculate_k","text":"Calculate the k-anonymity of each anonymized point based on surrounding address points. Typically more accurate the estimate_k . Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required address GeoDataFrame , optional A layer containing address points. required Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing k-anonymity.","title":"calculate_k()"},{"location":"api_reference/#maskmypy.tools.map_displacement","text":"Creates a map visualizing the displacement of each point between its original and masked location. Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required filename str , optional If specified, saves the output map to a file. None address GeoDataFrame , optional A layer containing address points. None Returns: Type Description matplotlib . pyplot . plt A plot depicting secret and masked points connected by lines.","title":"map_displacement()"},{"location":"donut/","text":"Donut Masking \u00b6 Donut masking Usage: To perform basic donut geomasking on a geodataframe containing secret points, with a maximum displacement distance of 500 meters and an minimum displacement distance of 20% of the maximum distance (i.e. 100 meters), the code would look like this: from maskmypy import Donut donutmask = Donut ( sensitive = sensitive , # Name of the sensitive geodataframe max_distance = 500 , # The maximum possible distance that points are displaced ratio = 0.2 , # The ratio used to define the minimum distance points are displaced distribution = 'uniform' , # The distribution to use when displacing points. Other options include 'gaussian' and 'areal'. 'Areal' distribution means points are more likely to be displaced further within the range. container = container ) # Optional, a geodataframe used to ensure that points do not leave a particular area. donutmask . run () masked = donutmask . mask To perform full donut geomasking (i.e. using census data and a target k-anonymity range rather than distance range) with a maximum k-anonymity of 1000 and minimum of 200, and a census geodataframe called population, the code would appear as follows: from maskmypy import Donut_K donutmask = Donut_K ( sensitive , # Name of the sensitive geodataframe population = population , # Name of the census geodataframe pop_col = 'pop' , # Name of the column containing the population field max_k = 1000 , # The maximum possible k-anonymity value ratio = 0.2 , # The ratio used to define the minimum possible k-anonymity value. distribution = 'uniform' , # The distribution to use when displacing points. Other options include 'gaussian' and 'areal'. 'Areal' distribution means points are more likely to be displaced further within the range. container = container ) # Optional, a geodataframe used to ensure that points do not leave a particular area. donutmask . run () masked = donutmask . mask","title":"Donut Masking"},{"location":"donut/#donut-masking","text":"Donut masking Usage: To perform basic donut geomasking on a geodataframe containing secret points, with a maximum displacement distance of 500 meters and an minimum displacement distance of 20% of the maximum distance (i.e. 100 meters), the code would look like this: from maskmypy import Donut donutmask = Donut ( sensitive = sensitive , # Name of the sensitive geodataframe max_distance = 500 , # The maximum possible distance that points are displaced ratio = 0.2 , # The ratio used to define the minimum distance points are displaced distribution = 'uniform' , # The distribution to use when displacing points. Other options include 'gaussian' and 'areal'. 'Areal' distribution means points are more likely to be displaced further within the range. container = container ) # Optional, a geodataframe used to ensure that points do not leave a particular area. donutmask . run () masked = donutmask . mask To perform full donut geomasking (i.e. using census data and a target k-anonymity range rather than distance range) with a maximum k-anonymity of 1000 and minimum of 200, and a census geodataframe called population, the code would appear as follows: from maskmypy import Donut_K donutmask = Donut_K ( sensitive , # Name of the sensitive geodataframe population = population , # Name of the census geodataframe pop_col = 'pop' , # Name of the column containing the population field max_k = 1000 , # The maximum possible k-anonymity value ratio = 0.2 , # The ratio used to define the minimum possible k-anonymity value. distribution = 'uniform' , # The distribution to use when displacing points. Other options include 'gaussian' and 'areal'. 'Areal' distribution means points are more likely to be displaced further within the range. container = container ) # Optional, a geodataframe used to ensure that points do not leave a particular area. donutmask . run () masked = donutmask . mask","title":"Donut Masking"},{"location":"street/","text":"Street Masking \u00b6 Street masking automatically downloads OpenStreetMap road network data and uses it to geographically mask your sensitive points. It works by first downloading the road network data, snapping each sensitive point to the nearest node on the network (an intersection or dead end), and then calculating the average network-distance between that node and a pool of the closest x number of nodes (e.g. the closest 20 nodes on the network, known as the search depth). This average distance is the target displacement distance. Finally, it selects a node from the pool whose network-distance from the starting node is closest to the target displacement distance. Usage: To street mask a GeoDataFrame containing sensitive points with a search-depth value of 20, the code would be as follows: from maskmypy import Street streetmask = Street ( sensitive , # Name of the sensitive GeoDataFrame depth = 20 , # The search depth value used to calculate displacement distances. padding = 2000 , # Used to download road network data surrounding the study area. Needs to be sufficiently large to reduce edge effects. Increasing reduces edge effects, but uses more memory. max_length = 500 ) # Optional, but recommended that you read below for full explanation of what this does. streetmask . run () # Single threaded by default. Add `parallel=True` as parameter to run on all CPU cores, drastically increasing performance. masked = streetmask . mask About max_length : when snapping points to the street network, the algorithm checks to make sure that the nearest node is actually connected to the network and has neighbors that are no more than max_length away (in meters). If it does not, then the next closest viable node is selected, checked, and so on. This acts as a sanity check to prevent extremely large masking distances. Feel free to change this to whatever you feel is appropriate. maskmypy.Street \u00b6 maskmypy . street . Street . __init__ ( * args , min_depth = 18 , max_depth = 20 , max_length = 500 , ** kwargs ) \u00b6 Constructs a street masking class that (when run) anonymizes points by randomly displacing them based on the surrounding street network using OpenStreetMap. Does not support containment. Parameters: Name Type Description Default min_depth int , optional The minimum number of nodes to traverse along the street network. Default: 18 18 max_depth int , optional The maximum number of nodes to traverse along the street network. Default: 20 20 max_length int , float , optional Sets a limit for street length, such that any street segments longer than this value will be ignored. Useful for ignoring very long streets that would skew the results, such as highways. 500","title":"Street Masking"},{"location":"street/#street-masking","text":"Street masking automatically downloads OpenStreetMap road network data and uses it to geographically mask your sensitive points. It works by first downloading the road network data, snapping each sensitive point to the nearest node on the network (an intersection or dead end), and then calculating the average network-distance between that node and a pool of the closest x number of nodes (e.g. the closest 20 nodes on the network, known as the search depth). This average distance is the target displacement distance. Finally, it selects a node from the pool whose network-distance from the starting node is closest to the target displacement distance. Usage: To street mask a GeoDataFrame containing sensitive points with a search-depth value of 20, the code would be as follows: from maskmypy import Street streetmask = Street ( sensitive , # Name of the sensitive GeoDataFrame depth = 20 , # The search depth value used to calculate displacement distances. padding = 2000 , # Used to download road network data surrounding the study area. Needs to be sufficiently large to reduce edge effects. Increasing reduces edge effects, but uses more memory. max_length = 500 ) # Optional, but recommended that you read below for full explanation of what this does. streetmask . run () # Single threaded by default. Add `parallel=True` as parameter to run on all CPU cores, drastically increasing performance. masked = streetmask . mask About max_length : when snapping points to the street network, the algorithm checks to make sure that the nearest node is actually connected to the network and has neighbors that are no more than max_length away (in meters). If it does not, then the next closest viable node is selected, checked, and so on. This acts as a sanity check to prevent extremely large masking distances. Feel free to change this to whatever you feel is appropriate.","title":"Street Masking"},{"location":"street/#maskmypystreet","text":"","title":"maskmypy.Street"},{"location":"street/#maskmypy.street.Street.__init__","text":"Constructs a street masking class that (when run) anonymizes points by randomly displacing them based on the surrounding street network using OpenStreetMap. Does not support containment. Parameters: Name Type Description Default min_depth int , optional The minimum number of nodes to traverse along the street network. Default: 18 18 max_depth int , optional The maximum number of nodes to traverse along the street network. Default: 20 20 max_length int , float , optional Sets a limit for street length, such that any street segments longer than this value will be ignored. Useful for ignoring very long streets that would skew the results, such as highways. 500","title":"__init__()"},{"location":"tests/","text":"Testing \u00b6 This is just a random sample","title":"Testing"},{"location":"tests/#testing","text":"This is just a random sample","title":"Testing"},{"location":"tools/","text":"K-Anonymity \u00b6 Maskmypy is able to calculate the k-anonymity of each point after masking. Two methods are available for this: estimates, and exact calculations. Estimates of k-anoynmity are inferred from census data, and assume a homogeneously distributed population within each census polygon. Address-based k-anonymity is more accurate and uses actual home address data to calculate k-anonymity. Estimate K-Anonymity \u00b6 Usage: After the data has been masked, estimating k-anoynmity using census data would look like this and will add a column to the masked geodataframe: mask . estimate_k ( population = population , # Name of the census geodataframe. Not necessary if you already included this parameter in the original masking steps. pop_col = 'pop' ) # Name of the column containing the population field. Not necessary if you already included this parameter in the original masking steps. Calculate K-Anonymity \u00b6 Usage: After the data has been masked, calcualting address-based k-anoynmity would look like this and will add a column to the masked geodataframe: mask . calculate_k ( address = '' ) # Name of the geodataframe including address points. Displacement Distance \u00b6 Usage: To add a column to the masked geodataframe that includes the actual displacement distances (in meters), one can just run: mask . displacement () tools.displacement() \u00b6 maskmypy . tools . displacement ( secret , mask , colname = '_distance' ) \u00b6 Calculates the displacement distance between secret and masked points. Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required colname str , optional Name for the output displacement distance column, by default \"_distance\" '_distance' Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing displacement distances","title":"Tools"},{"location":"tools/#k-anonymity","text":"Maskmypy is able to calculate the k-anonymity of each point after masking. Two methods are available for this: estimates, and exact calculations. Estimates of k-anoynmity are inferred from census data, and assume a homogeneously distributed population within each census polygon. Address-based k-anonymity is more accurate and uses actual home address data to calculate k-anonymity.","title":"K-Anonymity"},{"location":"tools/#estimate-k-anonymity","text":"Usage: After the data has been masked, estimating k-anoynmity using census data would look like this and will add a column to the masked geodataframe: mask . estimate_k ( population = population , # Name of the census geodataframe. Not necessary if you already included this parameter in the original masking steps. pop_col = 'pop' ) # Name of the column containing the population field. Not necessary if you already included this parameter in the original masking steps.","title":"Estimate K-Anonymity"},{"location":"tools/#calculate-k-anonymity","text":"Usage: After the data has been masked, calcualting address-based k-anoynmity would look like this and will add a column to the masked geodataframe: mask . calculate_k ( address = '' ) # Name of the geodataframe including address points.","title":"Calculate K-Anonymity"},{"location":"tools/#displacement-distance","text":"Usage: To add a column to the masked geodataframe that includes the actual displacement distances (in meters), one can just run: mask . displacement ()","title":"Displacement Distance"},{"location":"tools/#toolsdisplacement","text":"","title":"tools.displacement()"},{"location":"tools/#maskmypy.tools.displacement","text":"Calculates the displacement distance between secret and masked points. Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required colname str , optional Name for the output displacement distance column, by default \"_distance\" '_distance' Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing displacement distances","title":"displacement()"}]}