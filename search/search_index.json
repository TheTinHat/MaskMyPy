{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MaskMyPy \u00b6 Key Features \u00b6 Python tools for anonymizing geographic point data held in GeoDataFrames. Includes three approaches towards donut masking. Includes a new OpenStreetMap-based approach called street masking. Evaluation tools for assessing displacement distance & spatial k-anonymity. A command line interface (CLI) for quick masking jobs. Introduction \u00b6 MaskMyPy is a Python package that performs geographic masking on GeoDataFrames . In other words, it helps with anonymizing point data, such as confidential home addresses. It currently offers two main approaches towards anonymization: donut masking and street masking . MaskMyPy also includes evaluation tools to help optimize and validate masking parameters. These include k-anonymity estimation using population data, k-anonymity calculation using address data, and displacement distance calculation between secret and masked points. Use Cases: Why Geographic Masks? \u00b6 Geographic masks are techniques that protect confidential point data while still maintaining important spatial patterns within the dataset. While aggregation is often employed for privacy protection (as done by many censuses), aggregation reduces the usefulness of the data for statistical analysis. Example use cases for geographic masks include: A epidemiologist wants to release a dataset of patient addresses to help other researchers study the spread of a given disease. They also want anonymized points to remain inside the same census tract after masking to preserve statistical attributes. By utilizing donut masking and a containment layer, they are able to publish the dataset without compromising patient privacy, the location of important disease clusters, or census attributes. A mobile app developer wants to publish an end-of-year blog post with a map showing where their users have posted from, but is concerned about the privacy of their users. They utilize street masking to randomly displace points to nearby intersections on the street network before making the post. A criminologist wants to share a map of burglary locations but does not want to compromise victim privacy. They anonymize the dataset using street masking. To validate that their mask was effective they then calculate the spatial k-anonymity and displacement distance of each anonymized point. Realizing that some points were insufficiently protected, they tweak their masking parameters and repeat the process. Happy with the new results, they release the masked map. Disclaimer \u00b6 MaskMyPy is offered as-is, without warranty of any kind. Geographic masking is a hard problem that requires informed decisions and validation. MaskMyPy provides helpful tools for geographic masking, but does not replace expertise. Installation \u00b6 pip install maskmypy To also install optional dependencies (such as those required for displacement mapping): pip install maskmypy [ extra ] Usage \u00b6 Masking/Anonymization \u00b6 The following snippet applies a 500 meter donut mask to a GeoDataFrame of secret (e.g. sensitive) points: >>> from maskmypy import Donut >>> import geopandas as gpd >>> secret = gpd . read_file ( 'secret_points' ) >>> secret . head () CID geometry 0 1 POINT ( - 13703523.337 6313860.932 ) 1 2 POINT ( - 13703436.959 6314112.457 ) 2 3 POINT ( - 13703679.041 6314040.923 ) 3 4 POINT ( - 13703285.553 6313721.356 ) 4 5 POINT ( - 13703200.338 6313847.431 ) >>> masked_points = Donut ( secret , min_distance = 50 , max_distance = 500 ) . run () >>> masked_points . head () CID geometry 0 1 POINT ( - 13703383.941 6313989.161 ) 1 2 POINT ( - 13703227.863 6313973.121 ) 2 3 POINT ( - 13703313.001 6314172.582 ) 3 4 POINT ( - 13703107.232 6313614.978 ) 4 5 POINT ( - 13702837.385 6314140.874 ) Unless specified, MaskMyPy uses the same units of distance as the CRS of the input secret points. If our secret points instead used a CRS that is in feet, then our mask would have had a maximum distance of 500 feet. Evaluation \u00b6 We can also add some parameters to the .run() method to help us better evaluate our masking results. For instance, we can visually inspect the masking process by creating a rudimentary map of displacement distances like so: >>> masked_points = Donut ( secret , min_distance = 50 , max_distance = 500 ) . run ( map_displacement = True ) To more rigorously evaluate our results, we could add a context layer of address points and use it to calculate the k-anonymity of each masked point: >>> address_points = gpd . read_file ( 'addresses.shp' ) >>> masked_points = Donut ( secret , min_distance = 50 , max_distance = 500 , address = address_points ) . run ( calculate_k = True ) >>> masked_points . head () CID geometry k_calc 0 1 POINT ( - 13703383.941 6313989.161 ) 19 1 2 POINT ( - 13703227.863 6313973.121 ) 15 2 3 POINT ( - 13703313.001 6314172.582 ) 43 3 4 POINT ( - 13703107.232 6313614.978 ) 23 4 5 POINT ( - 13702837.385 6314140.874 ) 51 Of course, there are also use cases for geographic masking that may not involve addresses at all. In such cases, one could load an alternative point-based population layer in as an 'address' and receive similar benefits. For more information on what's available in the .run() method, see here . Command Line Interface (CLI) \u00b6 MaskMyPy also has a limited command line interface for quick jobs on shapefiles. The CLI contains commands for both donut and street masking classes (it does not support Donut_K or Donut_Multiply). Here's the command to street mask a input shapefile of points and save it as masked_points.shp : maskmypy street --max-depth 25 secret_points.shp masked_points.shp To find out more, just run maskmypy --help . Roadmap \u00b6 The following features are currently planned: Location Swapping/Verified Neighbor masks Mask metadata export Data suppression tools Contribute \u00b6 Any and all efforts to contribute are welcome, whether they include actual code or just feedback. In particular, I could use some help with: Architecture. Don't hesitate to point out things that look downright weird. Tests. A range of unit tests are already included for donut masking, but the street mask tests are currently a bit thin comparatively. The CLI could also use some tests. Documentation. Even just pointing out areas where you feel could use more documentation would be most helpful. Developers, please keep the following in mind: You can install the necessary development tools by cloning the repo and running pip install -e .[develop] . MaskMyPy uses black with a line length of 99 to format the codebase. Please run black -l 99 before submitting any pull requests. Run pytest from the project root before submitting any code changes to ensure that your changes do not break anything. Please include any appropriate unit tests with any feature contributions.","title":"Home"},{"location":"#maskmypy","text":"","title":"MaskMyPy"},{"location":"#key-features","text":"Python tools for anonymizing geographic point data held in GeoDataFrames. Includes three approaches towards donut masking. Includes a new OpenStreetMap-based approach called street masking. Evaluation tools for assessing displacement distance & spatial k-anonymity. A command line interface (CLI) for quick masking jobs.","title":"Key Features"},{"location":"#introduction","text":"MaskMyPy is a Python package that performs geographic masking on GeoDataFrames . In other words, it helps with anonymizing point data, such as confidential home addresses. It currently offers two main approaches towards anonymization: donut masking and street masking . MaskMyPy also includes evaluation tools to help optimize and validate masking parameters. These include k-anonymity estimation using population data, k-anonymity calculation using address data, and displacement distance calculation between secret and masked points.","title":"Introduction"},{"location":"#use-cases-why-geographic-masks","text":"Geographic masks are techniques that protect confidential point data while still maintaining important spatial patterns within the dataset. While aggregation is often employed for privacy protection (as done by many censuses), aggregation reduces the usefulness of the data for statistical analysis. Example use cases for geographic masks include: A epidemiologist wants to release a dataset of patient addresses to help other researchers study the spread of a given disease. They also want anonymized points to remain inside the same census tract after masking to preserve statistical attributes. By utilizing donut masking and a containment layer, they are able to publish the dataset without compromising patient privacy, the location of important disease clusters, or census attributes. A mobile app developer wants to publish an end-of-year blog post with a map showing where their users have posted from, but is concerned about the privacy of their users. They utilize street masking to randomly displace points to nearby intersections on the street network before making the post. A criminologist wants to share a map of burglary locations but does not want to compromise victim privacy. They anonymize the dataset using street masking. To validate that their mask was effective they then calculate the spatial k-anonymity and displacement distance of each anonymized point. Realizing that some points were insufficiently protected, they tweak their masking parameters and repeat the process. Happy with the new results, they release the masked map.","title":"Use Cases: Why Geographic Masks?"},{"location":"#disclaimer","text":"MaskMyPy is offered as-is, without warranty of any kind. Geographic masking is a hard problem that requires informed decisions and validation. MaskMyPy provides helpful tools for geographic masking, but does not replace expertise.","title":"Disclaimer"},{"location":"#installation","text":"pip install maskmypy To also install optional dependencies (such as those required for displacement mapping): pip install maskmypy [ extra ]","title":"Installation"},{"location":"#usage","text":"","title":"Usage"},{"location":"#maskinganonymization","text":"The following snippet applies a 500 meter donut mask to a GeoDataFrame of secret (e.g. sensitive) points: >>> from maskmypy import Donut >>> import geopandas as gpd >>> secret = gpd . read_file ( 'secret_points' ) >>> secret . head () CID geometry 0 1 POINT ( - 13703523.337 6313860.932 ) 1 2 POINT ( - 13703436.959 6314112.457 ) 2 3 POINT ( - 13703679.041 6314040.923 ) 3 4 POINT ( - 13703285.553 6313721.356 ) 4 5 POINT ( - 13703200.338 6313847.431 ) >>> masked_points = Donut ( secret , min_distance = 50 , max_distance = 500 ) . run () >>> masked_points . head () CID geometry 0 1 POINT ( - 13703383.941 6313989.161 ) 1 2 POINT ( - 13703227.863 6313973.121 ) 2 3 POINT ( - 13703313.001 6314172.582 ) 3 4 POINT ( - 13703107.232 6313614.978 ) 4 5 POINT ( - 13702837.385 6314140.874 ) Unless specified, MaskMyPy uses the same units of distance as the CRS of the input secret points. If our secret points instead used a CRS that is in feet, then our mask would have had a maximum distance of 500 feet.","title":"Masking/Anonymization"},{"location":"#evaluation","text":"We can also add some parameters to the .run() method to help us better evaluate our masking results. For instance, we can visually inspect the masking process by creating a rudimentary map of displacement distances like so: >>> masked_points = Donut ( secret , min_distance = 50 , max_distance = 500 ) . run ( map_displacement = True ) To more rigorously evaluate our results, we could add a context layer of address points and use it to calculate the k-anonymity of each masked point: >>> address_points = gpd . read_file ( 'addresses.shp' ) >>> masked_points = Donut ( secret , min_distance = 50 , max_distance = 500 , address = address_points ) . run ( calculate_k = True ) >>> masked_points . head () CID geometry k_calc 0 1 POINT ( - 13703383.941 6313989.161 ) 19 1 2 POINT ( - 13703227.863 6313973.121 ) 15 2 3 POINT ( - 13703313.001 6314172.582 ) 43 3 4 POINT ( - 13703107.232 6313614.978 ) 23 4 5 POINT ( - 13702837.385 6314140.874 ) 51 Of course, there are also use cases for geographic masking that may not involve addresses at all. In such cases, one could load an alternative point-based population layer in as an 'address' and receive similar benefits. For more information on what's available in the .run() method, see here .","title":"Evaluation"},{"location":"#command-line-interface-cli","text":"MaskMyPy also has a limited command line interface for quick jobs on shapefiles. The CLI contains commands for both donut and street masking classes (it does not support Donut_K or Donut_Multiply). Here's the command to street mask a input shapefile of points and save it as masked_points.shp : maskmypy street --max-depth 25 secret_points.shp masked_points.shp To find out more, just run maskmypy --help .","title":"Command Line Interface (CLI)"},{"location":"#roadmap","text":"The following features are currently planned: Location Swapping/Verified Neighbor masks Mask metadata export Data suppression tools","title":"Roadmap"},{"location":"#contribute","text":"Any and all efforts to contribute are welcome, whether they include actual code or just feedback. In particular, I could use some help with: Architecture. Don't hesitate to point out things that look downright weird. Tests. A range of unit tests are already included for donut masking, but the street mask tests are currently a bit thin comparatively. The CLI could also use some tests. Documentation. Even just pointing out areas where you feel could use more documentation would be most helpful. Developers, please keep the following in mind: You can install the necessary development tools by cloning the repo and running pip install -e .[develop] . MaskMyPy uses black with a line length of 99 to format the codebase. Please run black -l 99 before submitting any pull requests. Run pytest from the project root before submitting any code changes to ensure that your changes do not break anything. Please include any appropriate unit tests with any feature contributions.","title":"Contribute"},{"location":"donut/","text":"What is Donut Masking \u00b6 At its most basic, donut masking is an anonymization technique that works by randomly displacing each point between a specified minimum and maximum distance, as pictured below. This makes it a stronger form of random perturbation, which uses no minimum distance and thus runs the risk of insufficiently anonymizing points. MaskMyPy offers donut masking using the Donut masking class. Donut masking can be further strengthened by adding some form of population data into the mix. As one can imagine, a point in a downtown core won't need to be displaced nearly as far as a point in the surrounding suburbs to achieve similar levels of anonymity. As such, MaskMyPy offers two additional donut masking classes to help take population density into account: Donut_Multiply and Donut_K . Both masks require a context layer of polygons containing population counts (e.g. census tracts), but leverage this information in different ways. Donut_Multiply works by multiplying masking distances based on the relative population density of the polygon it falls within. This means that points in the most dense areas of a given dataset will have their masking distance multiplied by 1, whereas points within the least dense areas of that same dataset will have their masking distance multiplied by 5. Of course, this multiplier is configurable, 5 is just the default. Donut_K works a bit differently. Rather than taking a range of masking distances as input, Donut_K takes a desired level of anonymity as input, then figures out the masking distances that are required to achieve that. This level of anonymity is known as k-anonymity , and essentially refers to the size of crowd that the point (theoretically) blends into. There is a caveat to these population-based methods, however: MaskMyPy is only able to factor in the population density of the immediate polygon that the point falls within. This means that if there are neighboring polygons with significantly different population densities, they will not be accounted for. Note that the estimate_k tool will do this disaggregation and will therefore return different, but more accurate values. So as always, be careful, understand your data, and validate that the masked data is sufficiently protected. Example Usage \u00b6 To perform donut masking on a GeoDataFrame containing secret points with a range of 100 to 1000 meters: from maskmypy import Donut donutmask = Donut ( secret = my_secret_gdf , # Name of the secret GeoDataFrame. min_distance = 100 , # The minimum possible distance the points are displaced. max_distance = 1000 ) # The maximum possible distance that points are displaced. donutmask . run () # Execute the mask. masked = donutmask . mask # A masked GeoDataFrame. To perform more robust donut masking using census data to target a k-anonymity range, a containment layer to prevent points from being displaced to other counties, and a column describing the displacement distance of each point: from maskmypy import Donut_K donutmask = Donut_K ( secret = my_secret_gdf , # Name of the secret GeoDataFrame population = census_tracts , # Name of the GeoDataFrame containing population polygons. pop_col = 'pop' , # Name of the column containing the population field. min_k = 10 , # The minimum target k-anonymity value. max_k = 100 , # The maximum target k-anonymity value. distribution = 'gaussian' , # The distribution to use when displacing points. container = county_polygons ) # Optional, a GeoDataFrame used to ensure that points do not leave a particular area. donutmask . run ( displacement = true ) # Execute the mask and add a column describing displacement distance. masked = donutmask . mask Reference \u00b6 maskmypy.Donut(secret) Bases: Mask Constructs a donut masking class that (when run) anonymizes points by randomly displacing them between a minimum and maximum distance. Parameters: secret ( GeoDataFrame ) \u2013 Secret layer of points that require anonymization. All other GeoDataFrame inputs must match the CRS of the secret point layer. min_distance ( int , float ) \u2013 The minimum distance that points should be displaced. Default: 50 . max_distance ( int , float ) \u2013 The maximum distance that points should be displaced. Default: 500 . distribution ( str , optional ) \u2013 The distribution used to determine masking distances. The default uniform provides a flat distribution where any value between the minimum and maximum distance is equally likely to be selected. The areal distribution is more likely to select distances that are further away. The gaussian distribution uses a normal distribution, where values towards the middle of the range are most likely to be selected. Note that gaussian distribution has a small chance of selecting values beyond the defined minimum and maximum. Default: uniform . padding ( int , float , optional ) \u2013 Context layers (e.g. population, address, container, street network) are automatically cropped to the extent of the secret layer, plus some amount of padding to reduce edge effects. By default, padding is set to one fifth the x or y extent, whichever is larger. This parameter allows you to instead specify an exact amount of padding to be added. Recommended if the extent of the secret layer is either very small or very large. Units should match that of the secret layer's CRS. max_tries ( int , optional ) \u2013 The maximum number of times that MaskMyPy should re-mask a point until it is contained within the corresponding polygon (see container parameter). Default: 1000 . seed ( int , optional ) \u2013 Used to seed the random number generator so that masks are reproducible. In other words, given a certain seed, MaskMyPy will always mask data the exact same way. If left unspecified, a seed is randomly selected using SystemRandom population ( GeoDataFrame , optional ) \u2013 A polygon layer with a column describing population count. pop_col ( str , optional ) \u2013 The name of the population count column in the population polygon layer. Default: pop . container ( GeoDataFrame , optional ) \u2013 A layer containing polygons within which intersecting secret points should remain after masking. This works by masking a point, checking if it intersects the same polygon prior to masking, and retrying until it does. The number of attempts is controlled by the max_tries parameter. Useful for preserving statistical values, such as from census tracts, or to ensure that points are not displaced into impossible locations, such as the ocean. address ( GeoDataFrame , optional ) \u2013 A layer containing address points. maskmypy.Donut_Multiply(secret) Bases: Donut Constructs a masking class that (when run) anonymizes points by randomly displacing them according to a minimum and maximum distance, but with an additional multiplier to help take population density into account. Points in the most population-dense polygons will have their minimum and maximum masking distances multiplied by 1. This multiplier will increase linearly as population density decreases, with points in the least population-dense polygons having their minimum and maximum masking distances multiplied by the full population_mulitplier value. Requires a population layer. Parameters: secret ( GeoDataFrame ) \u2013 Secret layer of points that require anonymization. All other GeoDataFrame inputs must match the CRS of the secret point layer. min_distance ( int , float ) \u2013 The minimum distance that points should be displaced. max_distance ( int , float ) \u2013 The maximum distance that points should be displaced. population_multiplier ( int , float ) \u2013 The maximum possible multiplier used to extend masking distances according to population density. padding ( int , float , optional ) \u2013 Context layers (e.g. population, address, container, street network) are automatically cropped to the extent of the secret layer, plus some amount of padding to reduce edge effects. By default, padding is set to one fifth the x or y extent, whichever is larger. This parameter allows you to instead specify an exact amount of padding to be added. Recommended if the extent of the secret layer is either very small or very large. Units should match that of the secret layer's CRS. max_tries ( int , optional ) \u2013 The maximum number of times that MaskMyPy should re-mask a point until it is contained within the corresponding polygon (see container parameter). Default: 1000 . seed ( int , optional ) \u2013 Used to seed the random number generator so that masks are reproducible. In other words, given a certain seed, MaskMyPy will always mask data the exact same way. If left unspecified, a seed is randomly selected using SystemRandom population ( GeoDataFrame , optional ) \u2013 A polygon layer with a column describing population count. pop_col ( str , optional ) \u2013 The name of the population count column in the population polygon layer. Default: pop . container ( GeoDataFrame , optional ) \u2013 A layer containing polygons within which intersecting secret points should remain after masking. This works by masking a point, checking if it intersects the same polygon prior to masking, and retrying until it does. The number of attempts is controlled by the max_tries parameter. Useful for preserving statistical values, such as from census tracts, or to ensure that points are not displaced into impossible locations, such as the ocean. address ( GeoDataFrame , optional ) \u2013 A layer containing address points. maskmypy.Donut_K(secret) Bases: Donut Constructs a masking class that (when run) anonymizes points by randomly displacing them according to a desired k-anonymity range. Note that the k-anonymity values only reflect the population density of the immediate polygon the point falls within, and do not take into account any neighboring polygons. Requires a population layer. Parameters: secret ( GeoDataFrame ) \u2013 Secret layer of points that require anonymization. All other GeoDataFrame inputs must match the CRS of the secret point layer. min_k ( int ) \u2013 The minimum desired k-anonymity for each point. Please read description above to learn the limitations of this calculation. max_k ( int ) \u2013 The maximum desired k-anonymity for each point. Please read description above to learn the limitations of this calculation. padding ( int , float , optional ) \u2013 Context layers (e.g. population, address, container, street network) are automatically cropped to the extent of the secret layer, plus some amount of padding to reduce edge effects. By default, padding is set to one fifth the x or y extent, whichever is larger. This parameter allows you to instead specify an exact amount of padding to be added. Recommended if the extent of the secret layer is either very small or very large. Units should match that of the secret layer's CRS. max_tries ( int , optional ) \u2013 The maximum number of times that MaskMyPy should re-mask a point until it is contained within the corresponding polygon (see container parameter). Default: 1000 . seed ( int , optional ) \u2013 Used to seed the random number generator so that masks are reproducible. In other words, given a certain seed, MaskMyPy will always mask data the exact same way. If left unspecified, a seed is randomly selected using SystemRandom population ( GeoDataFrame , optional ) \u2013 A polygon layer with a column describing population count. pop_col ( str , optional ) \u2013 The name of the population count column in the population polygon layer. Default: pop . container ( GeoDataFrame , optional ) \u2013 A layer containing polygons within which intersecting secret points should remain after masking. This works by masking a point, checking if it intersects the same polygon prior to masking, and retrying until it does. The number of attempts is controlled by the max_tries parameter. Useful for preserving statistical values, such as from census tracts, or to ensure that points are not displaced into impossible locations, such as the ocean. address ( GeoDataFrame , optional ) \u2013 A layer containing address points.","title":"Donut Masking"},{"location":"donut/#what-is-donut-masking","text":"At its most basic, donut masking is an anonymization technique that works by randomly displacing each point between a specified minimum and maximum distance, as pictured below. This makes it a stronger form of random perturbation, which uses no minimum distance and thus runs the risk of insufficiently anonymizing points. MaskMyPy offers donut masking using the Donut masking class. Donut masking can be further strengthened by adding some form of population data into the mix. As one can imagine, a point in a downtown core won't need to be displaced nearly as far as a point in the surrounding suburbs to achieve similar levels of anonymity. As such, MaskMyPy offers two additional donut masking classes to help take population density into account: Donut_Multiply and Donut_K . Both masks require a context layer of polygons containing population counts (e.g. census tracts), but leverage this information in different ways. Donut_Multiply works by multiplying masking distances based on the relative population density of the polygon it falls within. This means that points in the most dense areas of a given dataset will have their masking distance multiplied by 1, whereas points within the least dense areas of that same dataset will have their masking distance multiplied by 5. Of course, this multiplier is configurable, 5 is just the default. Donut_K works a bit differently. Rather than taking a range of masking distances as input, Donut_K takes a desired level of anonymity as input, then figures out the masking distances that are required to achieve that. This level of anonymity is known as k-anonymity , and essentially refers to the size of crowd that the point (theoretically) blends into. There is a caveat to these population-based methods, however: MaskMyPy is only able to factor in the population density of the immediate polygon that the point falls within. This means that if there are neighboring polygons with significantly different population densities, they will not be accounted for. Note that the estimate_k tool will do this disaggregation and will therefore return different, but more accurate values. So as always, be careful, understand your data, and validate that the masked data is sufficiently protected.","title":"What is Donut Masking"},{"location":"donut/#example-usage","text":"To perform donut masking on a GeoDataFrame containing secret points with a range of 100 to 1000 meters: from maskmypy import Donut donutmask = Donut ( secret = my_secret_gdf , # Name of the secret GeoDataFrame. min_distance = 100 , # The minimum possible distance the points are displaced. max_distance = 1000 ) # The maximum possible distance that points are displaced. donutmask . run () # Execute the mask. masked = donutmask . mask # A masked GeoDataFrame. To perform more robust donut masking using census data to target a k-anonymity range, a containment layer to prevent points from being displaced to other counties, and a column describing the displacement distance of each point: from maskmypy import Donut_K donutmask = Donut_K ( secret = my_secret_gdf , # Name of the secret GeoDataFrame population = census_tracts , # Name of the GeoDataFrame containing population polygons. pop_col = 'pop' , # Name of the column containing the population field. min_k = 10 , # The minimum target k-anonymity value. max_k = 100 , # The maximum target k-anonymity value. distribution = 'gaussian' , # The distribution to use when displacing points. container = county_polygons ) # Optional, a GeoDataFrame used to ensure that points do not leave a particular area. donutmask . run ( displacement = true ) # Execute the mask and add a column describing displacement distance. masked = donutmask . mask","title":"Example Usage"},{"location":"donut/#reference","text":"maskmypy.Donut(secret) Bases: Mask Constructs a donut masking class that (when run) anonymizes points by randomly displacing them between a minimum and maximum distance. Parameters: secret ( GeoDataFrame ) \u2013 Secret layer of points that require anonymization. All other GeoDataFrame inputs must match the CRS of the secret point layer. min_distance ( int , float ) \u2013 The minimum distance that points should be displaced. Default: 50 . max_distance ( int , float ) \u2013 The maximum distance that points should be displaced. Default: 500 . distribution ( str , optional ) \u2013 The distribution used to determine masking distances. The default uniform provides a flat distribution where any value between the minimum and maximum distance is equally likely to be selected. The areal distribution is more likely to select distances that are further away. The gaussian distribution uses a normal distribution, where values towards the middle of the range are most likely to be selected. Note that gaussian distribution has a small chance of selecting values beyond the defined minimum and maximum. Default: uniform . padding ( int , float , optional ) \u2013 Context layers (e.g. population, address, container, street network) are automatically cropped to the extent of the secret layer, plus some amount of padding to reduce edge effects. By default, padding is set to one fifth the x or y extent, whichever is larger. This parameter allows you to instead specify an exact amount of padding to be added. Recommended if the extent of the secret layer is either very small or very large. Units should match that of the secret layer's CRS. max_tries ( int , optional ) \u2013 The maximum number of times that MaskMyPy should re-mask a point until it is contained within the corresponding polygon (see container parameter). Default: 1000 . seed ( int , optional ) \u2013 Used to seed the random number generator so that masks are reproducible. In other words, given a certain seed, MaskMyPy will always mask data the exact same way. If left unspecified, a seed is randomly selected using SystemRandom population ( GeoDataFrame , optional ) \u2013 A polygon layer with a column describing population count. pop_col ( str , optional ) \u2013 The name of the population count column in the population polygon layer. Default: pop . container ( GeoDataFrame , optional ) \u2013 A layer containing polygons within which intersecting secret points should remain after masking. This works by masking a point, checking if it intersects the same polygon prior to masking, and retrying until it does. The number of attempts is controlled by the max_tries parameter. Useful for preserving statistical values, such as from census tracts, or to ensure that points are not displaced into impossible locations, such as the ocean. address ( GeoDataFrame , optional ) \u2013 A layer containing address points. maskmypy.Donut_Multiply(secret) Bases: Donut Constructs a masking class that (when run) anonymizes points by randomly displacing them according to a minimum and maximum distance, but with an additional multiplier to help take population density into account. Points in the most population-dense polygons will have their minimum and maximum masking distances multiplied by 1. This multiplier will increase linearly as population density decreases, with points in the least population-dense polygons having their minimum and maximum masking distances multiplied by the full population_mulitplier value. Requires a population layer. Parameters: secret ( GeoDataFrame ) \u2013 Secret layer of points that require anonymization. All other GeoDataFrame inputs must match the CRS of the secret point layer. min_distance ( int , float ) \u2013 The minimum distance that points should be displaced. max_distance ( int , float ) \u2013 The maximum distance that points should be displaced. population_multiplier ( int , float ) \u2013 The maximum possible multiplier used to extend masking distances according to population density. padding ( int , float , optional ) \u2013 Context layers (e.g. population, address, container, street network) are automatically cropped to the extent of the secret layer, plus some amount of padding to reduce edge effects. By default, padding is set to one fifth the x or y extent, whichever is larger. This parameter allows you to instead specify an exact amount of padding to be added. Recommended if the extent of the secret layer is either very small or very large. Units should match that of the secret layer's CRS. max_tries ( int , optional ) \u2013 The maximum number of times that MaskMyPy should re-mask a point until it is contained within the corresponding polygon (see container parameter). Default: 1000 . seed ( int , optional ) \u2013 Used to seed the random number generator so that masks are reproducible. In other words, given a certain seed, MaskMyPy will always mask data the exact same way. If left unspecified, a seed is randomly selected using SystemRandom population ( GeoDataFrame , optional ) \u2013 A polygon layer with a column describing population count. pop_col ( str , optional ) \u2013 The name of the population count column in the population polygon layer. Default: pop . container ( GeoDataFrame , optional ) \u2013 A layer containing polygons within which intersecting secret points should remain after masking. This works by masking a point, checking if it intersects the same polygon prior to masking, and retrying until it does. The number of attempts is controlled by the max_tries parameter. Useful for preserving statistical values, such as from census tracts, or to ensure that points are not displaced into impossible locations, such as the ocean. address ( GeoDataFrame , optional ) \u2013 A layer containing address points. maskmypy.Donut_K(secret) Bases: Donut Constructs a masking class that (when run) anonymizes points by randomly displacing them according to a desired k-anonymity range. Note that the k-anonymity values only reflect the population density of the immediate polygon the point falls within, and do not take into account any neighboring polygons. Requires a population layer. Parameters: secret ( GeoDataFrame ) \u2013 Secret layer of points that require anonymization. All other GeoDataFrame inputs must match the CRS of the secret point layer. min_k ( int ) \u2013 The minimum desired k-anonymity for each point. Please read description above to learn the limitations of this calculation. max_k ( int ) \u2013 The maximum desired k-anonymity for each point. Please read description above to learn the limitations of this calculation. padding ( int , float , optional ) \u2013 Context layers (e.g. population, address, container, street network) are automatically cropped to the extent of the secret layer, plus some amount of padding to reduce edge effects. By default, padding is set to one fifth the x or y extent, whichever is larger. This parameter allows you to instead specify an exact amount of padding to be added. Recommended if the extent of the secret layer is either very small or very large. Units should match that of the secret layer's CRS. max_tries ( int , optional ) \u2013 The maximum number of times that MaskMyPy should re-mask a point until it is contained within the corresponding polygon (see container parameter). Default: 1000 . seed ( int , optional ) \u2013 Used to seed the random number generator so that masks are reproducible. In other words, given a certain seed, MaskMyPy will always mask data the exact same way. If left unspecified, a seed is randomly selected using SystemRandom population ( GeoDataFrame , optional ) \u2013 A polygon layer with a column describing population count. pop_col ( str , optional ) \u2013 The name of the population count column in the population polygon layer. Default: pop . container ( GeoDataFrame , optional ) \u2013 A layer containing polygons within which intersecting secret points should remain after masking. This works by masking a point, checking if it intersects the same polygon prior to masking, and retrying until it does. The number of attempts is controlled by the max_tries parameter. Useful for preserving statistical values, such as from census tracts, or to ensure that points are not displaced into impossible locations, such as the ocean. address ( GeoDataFrame , optional ) \u2013 A layer containing address points.","title":"Reference"},{"location":"street/","text":"What is Street Masking \u00b6 Street masking automatically downloads OpenStreetMap data and uses it to geographically mask your secret points. It provides some of the advantages of population-based masks without requiring the user to hunt down any additional data. It works by first downloading the road network, snapping each secret point to the nearest node on the network (e.g. an intersection or dead end), and then calculating the average network-distance between that node and a pool of the closest n nodes. Note that n is randomly determined for each point from a specified range between min_depth and max_depth . This average distance is used as the target displacement distance. Finally, it selects a node from the pool whose network-distance from the starting node is closest to the target displacement distance. You can read more about street masking in this peer reviewed article . (Note: this diagram is slightly dated as street masking now includes a randomization element. Specifically, depth values are now provided as a range within which a value is selected at random for each point. This makes it more difficult for an attacker to re-identify any given masked point.) Example Usage \u00b6 To street mask a GeoDataFrame containing secret points with a search-depth range of 20-30 nodes into the street network: from maskmypy import Street streetmask = Street ( secret = my_secret_gdf , # Name of the secret GeoDataFrame. min_depth = 20 , # The minimum depth into the street network that will be traversed. max_depth = 30 , # The maximum depth into the street network that will be traversed. seed = 12957134581 , # A seed value to ensure reproducible results. address = address_points_gdf ) # Layer of address points used in the next line to calculate k-anonymity. streetmask . run ( calculate_k = true ) # Execute the mask and add a column describing the k-anonymity of each point. masked = streetmask . mask Reference \u00b6 maskmypy.Street(secret) Bases: Mask Constructs a street masking class that (when run) anonymizes points by randomly displacing them based on the surrounding street network using OpenStreetMap. Does not support containment. Parameters: secret ( GeoDataFrame ) \u2013 Secret layer of points that require anonymization. All other GeoDataFrame inputs must match the CRS of the secret point layer. min_depth ( int , optional ) \u2013 The minimum number of nodes to traverse along the street network. Default: 18 max_depth ( int , optional ) \u2013 The maximum number of nodes to traverse along the street network. Default: 20 max_length ( int , float , optional ) \u2013 When initially locating each point on the street network, MaskMyPy verifies that the nearest node is actually connected to the network and has neighbors that are no more than max_length away (in meters). If not, the next closest point is selected and checked the same way. This acts as a sanity check to prevent extremely large masking distances, such as might be caused by highways. Default: 500 . padding ( int , float , optional ) \u2013 Context layers (e.g. population, address, container, street network) are automatically cropped to the extent of the secret layer, plus some amount of padding to reduce edge effects. By default, padding is set to one fifth the x or y extent, whichever is larger. This parameter allows you to instead specify an exact amount of padding to be added. Recommended if the extent of the secret layer is either very small or very large. Units should match that of the secret layer's CRS. seed ( int , optional ) \u2013 Used to seed the random number generator so that masks are reproducible. In other words, given a certain seed, MaskMyPy will always mask data the exact same way. If left unspecified, a seed is randomly selected using SystemRandom population ( GeoDataFrame , optional ) \u2013 A polygon layer with a column describing population count. pop_col ( str , optional ) \u2013 The name of the population count column in the population polygon layer. Default: pop . address ( GeoDataFrame , optional ) \u2013 A layer containing address points.","title":"Street Masking"},{"location":"street/#what-is-street-masking","text":"Street masking automatically downloads OpenStreetMap data and uses it to geographically mask your secret points. It provides some of the advantages of population-based masks without requiring the user to hunt down any additional data. It works by first downloading the road network, snapping each secret point to the nearest node on the network (e.g. an intersection or dead end), and then calculating the average network-distance between that node and a pool of the closest n nodes. Note that n is randomly determined for each point from a specified range between min_depth and max_depth . This average distance is used as the target displacement distance. Finally, it selects a node from the pool whose network-distance from the starting node is closest to the target displacement distance. You can read more about street masking in this peer reviewed article . (Note: this diagram is slightly dated as street masking now includes a randomization element. Specifically, depth values are now provided as a range within which a value is selected at random for each point. This makes it more difficult for an attacker to re-identify any given masked point.)","title":"What is Street Masking"},{"location":"street/#example-usage","text":"To street mask a GeoDataFrame containing secret points with a search-depth range of 20-30 nodes into the street network: from maskmypy import Street streetmask = Street ( secret = my_secret_gdf , # Name of the secret GeoDataFrame. min_depth = 20 , # The minimum depth into the street network that will be traversed. max_depth = 30 , # The maximum depth into the street network that will be traversed. seed = 12957134581 , # A seed value to ensure reproducible results. address = address_points_gdf ) # Layer of address points used in the next line to calculate k-anonymity. streetmask . run ( calculate_k = true ) # Execute the mask and add a column describing the k-anonymity of each point. masked = streetmask . mask","title":"Example Usage"},{"location":"street/#reference","text":"maskmypy.Street(secret) Bases: Mask Constructs a street masking class that (when run) anonymizes points by randomly displacing them based on the surrounding street network using OpenStreetMap. Does not support containment. Parameters: secret ( GeoDataFrame ) \u2013 Secret layer of points that require anonymization. All other GeoDataFrame inputs must match the CRS of the secret point layer. min_depth ( int , optional ) \u2013 The minimum number of nodes to traverse along the street network. Default: 18 max_depth ( int , optional ) \u2013 The maximum number of nodes to traverse along the street network. Default: 20 max_length ( int , float , optional ) \u2013 When initially locating each point on the street network, MaskMyPy verifies that the nearest node is actually connected to the network and has neighbors that are no more than max_length away (in meters). If not, the next closest point is selected and checked the same way. This acts as a sanity check to prevent extremely large masking distances, such as might be caused by highways. Default: 500 . padding ( int , float , optional ) \u2013 Context layers (e.g. population, address, container, street network) are automatically cropped to the extent of the secret layer, plus some amount of padding to reduce edge effects. By default, padding is set to one fifth the x or y extent, whichever is larger. This parameter allows you to instead specify an exact amount of padding to be added. Recommended if the extent of the secret layer is either very small or very large. Units should match that of the secret layer's CRS. seed ( int , optional ) \u2013 Used to seed the random number generator so that masks are reproducible. In other words, given a certain seed, MaskMyPy will always mask data the exact same way. If left unspecified, a seed is randomly selected using SystemRandom population ( GeoDataFrame , optional ) \u2013 A polygon layer with a column describing population count. pop_col ( str , optional ) \u2013 The name of the population count column in the population polygon layer. Default: pop . address ( GeoDataFrame , optional ) \u2013 A layer containing address points.","title":"Reference"},{"location":"tools/","text":"Warning : Do not release datasets containing displacement distances or k-anonymity values. These are only to assist the person masking the data. Releasing such values may compromise privacy and aid attackers seeking to re-identify point locations. Always remove these columns before sharing the data. K-Anonymity \u00b6 Maskmypy is able to calculate the k-anonymity of each point after masking. Two methods are available for this: estimate_k and calculate_k . Estimates of k-anonymity are inferred from population data, and assume a homogeneously distributed population within each population (i.e. census) polygon. Address-based k-anonymity is more accurate and uses actual address data to calculate k-anonymity. maskmypy.tools.estimate_k(secret, mask, population) Estimate the k-anonymity of each anonymized point based on surrounding population density. Note that unlike in Donut_K , neighboring polygons will be disaggregated and included to more accurately estimate k-anonymity. Typically less accurate the calculate_k . Parameters: secret ( GeoDataFrame ) \u2013 Secret points prior to masking. mask ( GeoDataFrame ) \u2013 Points after masking population ( GeoDataFrame ) \u2013 A polygon layer with a column describing population count. pop_col ( str , optional ) \u2013 The name of the population count column in the population polygon layer. Default: pop . Returns: GeoDataFrame \u2013 A GeoDataFrame with a k_est column describing k-anonymity. maskmypy.tools.calculate_k(secret, mask, address) Calculate the k-anonymity of each anonymized point based on surrounding address points. Typically more accurate the estimate_k . Parameters: secret ( GeoDataFrame ) \u2013 Secret points prior to masking. mask ( GeoDataFrame ) \u2013 Points after masking address ( GeoDataFrame , optional ) \u2013 A layer containing address points. Returns: GeoDataFrame \u2013 A GeoDataFrame with a k_calc column describing k-anonymity. Displacement Distance \u00b6 Displacement distance refers to the distance that each point is moved from its original location during anonymization. They are helpful insofar as they allow you to assess how much your data has been distorted by the masking process, both in terms of too much or too little. For instance, you may find that one point was only moved 6 meters, which doesn't protect privacy much at all. Alternatively, you may find that some points were displaced too far, say 6000 meters. MaskMyPy can easily calculate the displacement distance of masked data as well as generate a quick map of displacement distances to help you visually inspect the anonymization results. maskmypy.tools.displacement(secret, mask) Calculates the displacement distance between secret and masked points. Parameters: secret ( GeoDataFrame ) \u2013 Secret points prior to masking. mask ( GeoDataFrame ) \u2013 Points after masking colname ( str , optional ) \u2013 Name for the output displacement distance column. Default: _distance . Returns: GeoDataFrame \u2013 A GeoDataFrame with a column describing displacement distances maskmypy.tools.map_displacement(secret, mask) Creates a map visualizing the displacement of each point between its original and masked location. Parameters: secret ( GeoDataFrame ) \u2013 Secret points prior to masking. mask ( GeoDataFrame ) \u2013 Points after masking filename ( str , optional ) \u2013 If specified, saves the output map to a file. address ( GeoDataFrame , optional ) \u2013 A layer containing address points. Returns: matplotlib . pyplot . plt \u2013 A plot depicting secret and masked points connected by lines. Shortcut: Evaluation Using .run() \u00b6 For convenience, several evaluation tools can be quickly executed by adding flags to the .run() method of each masking class. Here is the docstring for .run() : Run the masking procedure to anonymize secret points. Parameters: displacement ( bool , optional ) \u2013 If True , add a distance column containing the displacement distance. estimate_k ( bool , optional ) \u2013 If True , estimate the k-anonymity of each anonymized point based on surrounding population density. Requires a population layer to be loaded into the masking object. calculate_k ( bool , optional ) \u2013 If True , calculate the k-anonymity of each anonymized point based on nearby address points. Requires an address layer to be loaded into the masking class. map_displacement ( bool , optional ) \u2013 If True , output a file called displacement_map.png that visualizes displacement distance between secret and masked points. Returns: GeoDataFrame \u2013 A GeoDataFrame of anonymized points.","title":"Evaluation Tools"},{"location":"tools/#k-anonymity","text":"Maskmypy is able to calculate the k-anonymity of each point after masking. Two methods are available for this: estimate_k and calculate_k . Estimates of k-anonymity are inferred from population data, and assume a homogeneously distributed population within each population (i.e. census) polygon. Address-based k-anonymity is more accurate and uses actual address data to calculate k-anonymity. maskmypy.tools.estimate_k(secret, mask, population) Estimate the k-anonymity of each anonymized point based on surrounding population density. Note that unlike in Donut_K , neighboring polygons will be disaggregated and included to more accurately estimate k-anonymity. Typically less accurate the calculate_k . Parameters: secret ( GeoDataFrame ) \u2013 Secret points prior to masking. mask ( GeoDataFrame ) \u2013 Points after masking population ( GeoDataFrame ) \u2013 A polygon layer with a column describing population count. pop_col ( str , optional ) \u2013 The name of the population count column in the population polygon layer. Default: pop . Returns: GeoDataFrame \u2013 A GeoDataFrame with a k_est column describing k-anonymity. maskmypy.tools.calculate_k(secret, mask, address) Calculate the k-anonymity of each anonymized point based on surrounding address points. Typically more accurate the estimate_k . Parameters: secret ( GeoDataFrame ) \u2013 Secret points prior to masking. mask ( GeoDataFrame ) \u2013 Points after masking address ( GeoDataFrame , optional ) \u2013 A layer containing address points. Returns: GeoDataFrame \u2013 A GeoDataFrame with a k_calc column describing k-anonymity.","title":"K-Anonymity"},{"location":"tools/#displacement-distance","text":"Displacement distance refers to the distance that each point is moved from its original location during anonymization. They are helpful insofar as they allow you to assess how much your data has been distorted by the masking process, both in terms of too much or too little. For instance, you may find that one point was only moved 6 meters, which doesn't protect privacy much at all. Alternatively, you may find that some points were displaced too far, say 6000 meters. MaskMyPy can easily calculate the displacement distance of masked data as well as generate a quick map of displacement distances to help you visually inspect the anonymization results. maskmypy.tools.displacement(secret, mask) Calculates the displacement distance between secret and masked points. Parameters: secret ( GeoDataFrame ) \u2013 Secret points prior to masking. mask ( GeoDataFrame ) \u2013 Points after masking colname ( str , optional ) \u2013 Name for the output displacement distance column. Default: _distance . Returns: GeoDataFrame \u2013 A GeoDataFrame with a column describing displacement distances maskmypy.tools.map_displacement(secret, mask) Creates a map visualizing the displacement of each point between its original and masked location. Parameters: secret ( GeoDataFrame ) \u2013 Secret points prior to masking. mask ( GeoDataFrame ) \u2013 Points after masking filename ( str , optional ) \u2013 If specified, saves the output map to a file. address ( GeoDataFrame , optional ) \u2013 A layer containing address points. Returns: matplotlib . pyplot . plt \u2013 A plot depicting secret and masked points connected by lines.","title":"Displacement Distance"},{"location":"tools/#shortcut-evaluation-using-run","text":"For convenience, several evaluation tools can be quickly executed by adding flags to the .run() method of each masking class. Here is the docstring for .run() : Run the masking procedure to anonymize secret points. Parameters: displacement ( bool , optional ) \u2013 If True , add a distance column containing the displacement distance. estimate_k ( bool , optional ) \u2013 If True , estimate the k-anonymity of each anonymized point based on surrounding population density. Requires a population layer to be loaded into the masking object. calculate_k ( bool , optional ) \u2013 If True , calculate the k-anonymity of each anonymized point based on nearby address points. Requires an address layer to be loaded into the masking class. map_displacement ( bool , optional ) \u2013 If True , output a file called displacement_map.png that visualizes displacement distance between secret and masked points. Returns: GeoDataFrame \u2013 A GeoDataFrame of anonymized points.","title":"Shortcut: Evaluation Using .run()"}]}