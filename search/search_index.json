{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#maskmypy","title":"MaskMyPy","text":"<p>Warning: This documentation reflects a upcoming beta release of MaskMyPy. </p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Python tools for anonymizing geographic point data held in GeoDataFrames.</li> <li>Includes four masks: donut, street, location swap, and voronoi.</li> <li>Evaluation tools for assessing information loss and privacy protection.</li> <li>An <code>Atlas</code> tool that allows for rapid experimentation of mask types and parameters.</li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p>MaskMyPy (GitHub | Docs) is a Python package that performs geographic masking on GeoDataFrames. In other words, it helps with anonymizing point data, such as confidential home addresses. It currently offers four main approaches towards anonymization: donut masking, street masking, location swapping, and voronoi masking.</p> <p>MaskMyPy also offers a range of analysis tools to help assess mask performance. These include functions for calculating:</p> <ul> <li>k-anonymity using either address points or population polygons (e.g. census data)</li> <li>displacement distance</li> <li>clustering based on Ripley's K-function</li> <li>nearest neighbor distances</li> <li>and more!</li> </ul>"},{"location":"#use-cases-why-geographic-masks","title":"Use Cases: Why Geographic Masks?","text":"<p>Geographic masks are techniques that protect confidential point data while still maintaining important spatial patterns within the dataset. While aggregation is often employed for privacy protection (as done by many censuses), aggregation reduces the usefulness of the data for statistical analysis. Example use cases for geographic masks include:</p> <ul> <li>A epidemiologist wants to release a dataset of patient addresses to help other researchers study the spread of a given disease. They also want anonymized points to remain inside the same census tract after masking to preserve statistical attributes. By utilizing donut masking and a containment layer, they are able to publish the dataset without compromising patient privacy, the location of important disease clusters, or census attributes.</li> <li>A mobile app developer wants to publish an end-of-year blog post with a map showing where their users have posted from, but is concerned about the privacy of their users. They utilize street masking to randomly displace points to nearby intersections on the street network before making the post.</li> <li>A criminologist wants to share a map of burglary locations but does not want to compromise victim privacy. They anonymize the dataset using street masking. To validate that their mask was effective they then calculate the spatial k-anonymity and displacement distance of each anonymized point. Realizing that some points were insufficiently protected, they tweak their masking parameters and repeat the process. Happy with the new results, they release the masked map.</li> </ul>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>MaskMyPy is offered as-is, without warranty of any kind. Geographic masking is a hard problem that requires informed decisions and validation. MaskMyPy provides helpful tools for geographic masking, but does not replace expertise.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install maskmypy\n</code></pre> <p>To also install optional dependencies (such as those required for displacement mapping):</p> <pre><code>pip install maskmypy[extra]\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#maskinganonymization","title":"Masking/Anonymization","text":"<p>The following snippet applies a 500 meter donut mask to a GeoDataFrame of secret (e.g. sensitive) points:</p> <pre><code>from maskmypy import donut\nimport geopandas as gpd\nsecret_points = gpd.read_file('secret_points.shp')\nmasked_points = donut(secret_points, min=50, max=500)\n</code></pre> <p>Unless specified, MaskMyPy uses the same units of distance as the CRS of the input secret points. If our secret points instead used a CRS that is in feet, then our mask would have had a maximum distance of 500 feet.</p>"},{"location":"#evaluation","title":"Evaluation","text":"<p>If we wanted to analyze how effective this mask was, we can leverage many of the analysis tools MaskMyPy offers by using a convenience function called <code>evaluate()</code>:</p> <pre><code>from maskmypy import analysis\ncensus_polygons = gpd.read_file('census.shp')\n\n# Return a dictionary containing evaluation results\nmask_stats = analysis.evaluate(\n  sensitive_gdf=secret_points,\n  candidate_gdf=masked_points,\n  population_gdf=census_polygons,\n  population_column=\"population\"\n)\n</code></pre>"},{"location":"#the-atlas","title":"The Atlas","text":"<p>The <code>Atlas()</code> class makes it easy to both mask datasets and evaluate new masks. It acts as a type of manager that allows you to quickly test any number of combinations of masks and their associated parameters, automatically performing the evaluation for you and keeping track of the results. Each result is referred to as a 'candidate' and is kept in a list at <code>Atlas.candidates</code>, which you can also access by slicing the Atlas itself (e.g. <code>Atlas[0]</code>).</p> <pre><code>import geopandas as gpd\nfrom maskmypy import Atlas, donut, street, locationswap\n\n# Load some data\npoints = gpd.read_file('sensitive_points.shp')\naddresses = gpd.read_file('address_points.shp')\n\n# Instantiate the Atlas\natlas = Atlas(points, population=addresses)\n\n# The mask() method takes any mask callable, with its arguments simply specified as keyword arguments\natlas.mask(donut, low=10, high=100) # Donut mask with small distances.\natlas.mask(donut, low=50, high=500) # Donut mask with larger distances.\n\natlas.mask(street, low=5, high=15) # Street masking.\natlas.mask(locationswap, low=50, high=500, address=addresses) # Location swapping.\n\natlas.as_df() # Return a nicely formatted dataframe detailing the results of each mask.\n\natlas.sort(\"k_min\", desc=True) # Sort the list of results by minimum k_anonymity.\n\n# The Atlas doesn't keep every masked gdf after it's done evaluating it. This is done to save memory.\n# But we can reproduce an *exact copy* using the `gen_gdf()` method!\n# The number represents the index in the candidate list. We sorted it by minimum k_anonymity, so\n# this will return the masked gdf with the highest minimum k-anonymity.\nmasked_gdf = atlas.gen_gdf(0)\n</code></pre>"},{"location":"#contribute","title":"Contribute","text":"<p>Any and all efforts to contribute are welcome, whether they include actual code or just feedback. Please find the GitHub repo here.</p> <p>Developers, please keep the following in mind:</p> <ul> <li>You can install the necessary development tools by cloning the repo and running <code>pip install -e .[develop]</code>.</li> <li>MaskMyPy uses <code>black</code> with a line length of 99 to format the codebase. Please run <code>black -l 99</code> before submitting any pull requests.</li> <li>Run <code>pytest</code> from the project root before submitting any code changes to ensure that your changes do not break anything.</li> <li>Please include tests with any feature contributions.</li> </ul>"},{"location":"analysis/","title":"Analysis","text":""},{"location":"analysis/#maskmypy.analysis","title":"<code>maskmypy.analysis</code>","text":""},{"location":"analysis/#maskmypy.analysis.central_drift","title":"<code>central_drift(sensitive_gdf, candidate_gdf)</code>","text":"<p>Calculates how far the centroid of the point pattern has been displaced due to masking. Higher central drift indicates more information loss.</p> <p>Parameters:</p> Name Type Description Default <code>sensitive_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing sensitive points prior to masking.</p> required <code>candidate_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing masked points.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The central drift, with units equal to the CRS of the <code>sensitive_gdf</code>.</p> Source code in <code>maskmypy/analysis.py</code> <pre><code>def central_drift(sensitive_gdf: GeoDataFrame, candidate_gdf: GeoDataFrame) -&gt; float:\n    \"\"\"\n    Calculates how far the centroid of the point pattern has been displaced due to masking.\n    Higher central drift indicates more information loss.\n\n    Parameters\n    ----------\n    sensitive_gdf : GeoDataFrame\n        A GeoDataFrame containing sensitive points prior to masking.\n    candidate_gdf : GeoDataFrame\n        A GeoDataFrame containing masked points.\n\n    Returns\n    -------\n    float\n        The central drift, with units equal to the CRS of the `sensitive_gdf`.\n    \"\"\"\n    centroid_a = sensitive_gdf.dissolve().centroid\n    centroid_b = candidate_gdf.dissolve().centroid\n    return round(float(centroid_a.distance(centroid_b).iloc[0]), 6)\n</code></pre>"},{"location":"analysis/#maskmypy.analysis.displacement","title":"<code>displacement(sensitive_gdf, candidate_gdf, col='_distance')</code>","text":"<p>Adds a column to the <code>candidate_gdf</code> containing the distance between each masked point and its original, unmasked location (<code>sensitive_gdf</code>).</p> <p>Parameters:</p> Name Type Description Default <code>sensitive_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing sensitive points prior to masking.</p> required <code>candidate_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing masked points.</p> required <code>col</code> <code>str</code> <p>Name of the displacement distance column to add to <code>candidate_gdf</code>.</p> <code>'_distance'</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>The <code>candidate_gdf</code> with an additional column describing displacement distance.</p> Source code in <code>maskmypy/analysis.py</code> <pre><code>def displacement(\n    sensitive_gdf: GeoDataFrame, candidate_gdf: GeoDataFrame, col: str = \"_distance\"\n) -&gt; GeoDataFrame:\n    \"\"\"\n    Adds a column to the `candidate_gdf` containing the distance between each masked point\n    and its original, unmasked location (`sensitive_gdf`).\n\n    Parameters\n    ----------\n    sensitive_gdf : GeoDataFrame\n        A GeoDataFrame containing sensitive points prior to masking.\n    candidate_gdf : GeoDataFrame\n        A GeoDataFrame containing masked points.\n    col : str\n        Name of the displacement distance column to add to `candidate_gdf`.\n\n    Returns\n    -------\n    GeoDataFrame\n        The `candidate_gdf` with an additional column describing displacement distance.\n    \"\"\"\n    candidate_gdf = candidate_gdf.copy()\n    candidate_gdf[col] = candidate_gdf.geometry.distance(sensitive_gdf.geometry)\n    return candidate_gdf\n</code></pre>"},{"location":"analysis/#maskmypy.analysis.evaluate","title":"<code>evaluate(sensitive_gdf, candidate_gdf, population_gdf=None, population_column='pop', skip_slow=True)</code>","text":"<p>Evaluate the privacy protection and information loss of a masked dataset (<code>candidate_gdf</code>) compared to the unmasked sensitive dataset (<code>sensitive_gdf</code>). This is a convenience function that automatically runs many of the analysis tools that MaskMyPy offers, returning a simple dictionary of results. Note that privacy metrics require a <code>population_gdf</code> to be provided.</p> <p>Parameters:</p> Name Type Description Default <code>sensitive_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing sensitive points prior to masking.</p> required <code>candidate_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing masked points to be evaluated.</p> required <code>population_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing either address points or polygons with a population column (see <code>population_column</code>). Used to calculate k-anonymity metrics.</p> <code>None</code> <code>population_column</code> <code>str</code> <p>If a polygon-based <code>population_gdf</code> is provided, the name of the column containing population counts.</p> <code>'pop'</code> <code>skip_slow</code> <code>bool</code> <p>If True, skips analyses that are known to be slow. Currently, this only includes the root-mean-square error of Ripley's K results between the masked and unmasked data.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing evaluation results.</p> Source code in <code>maskmypy/analysis.py</code> <pre><code>def evaluate(\n    sensitive_gdf: GeoDataFrame,\n    candidate_gdf: GeoDataFrame,\n    population_gdf: GeoDataFrame = None,\n    population_column: str = \"pop\",\n    skip_slow: bool = True,\n) -&gt; dict:\n    \"\"\"\n    Evaluate the privacy protection and information loss of a masked dataset (`candidate_gdf`)\n    compared to the unmasked sensitive dataset (`sensitive_gdf`). This is a convenience function\n    that automatically runs many of the analysis tools that MaskMyPy offers, returning a simple\n    dictionary of results. Note that privacy metrics require a `population_gdf` to be provided.\n\n    Parameters\n    ----------\n    sensitive_gdf : GeoDataFrame\n        A GeoDataFrame containing sensitive points prior to masking.\n    candidate_gdf : GeoDataFrame\n        A GeoDataFrame containing masked points to be evaluated.\n    population_gdf : GeoDataFrame\n        A GeoDataFrame containing either address points or polygons with a population column\n        (see `population_column`). Used to calculate k-anonymity metrics.\n    population_column : str\n        If a polygon-based `population_gdf` is provided, the name of the column containing\n        population counts.\n    skip_slow : bool\n        If True, skips analyses that are known to be slow. Currently, this only includes the\n        root-mean-square error of Ripley's K results between the masked and unmasked data.\n\n    Returns\n    -------\n    dict\n        A dictionary containing evaluation results.\n    \"\"\"\n    stats = {}\n\n    # Information Loss\n    stats[\"central_drift\"] = central_drift(\n        sensitive_gdf=sensitive_gdf, candidate_gdf=candidate_gdf\n    )\n    stats.update(\n        summarize_displacement(\n            displacement(\n                sensitive_gdf=sensitive_gdf,\n                candidate_gdf=candidate_gdf,\n            )\n        )\n    )\n    stats.update(nnd_delta(sensitive_gdf=sensitive_gdf, candidate_gdf=candidate_gdf))\n    if not skip_slow:\n        stats[\"ripley_rmse\"] = ripley_rmse(ripleys_k(sensitive_gdf), ripleys_k(candidate_gdf))\n\n    # Privacy\n    if isinstance(population_gdf, GeoDataFrame):\n        k_gdf = k_anonymity(\n            sensitive_gdf=sensitive_gdf,\n            candidate_gdf=candidate_gdf,\n            population_gdf=population_gdf,\n            population_column=population_column,\n        )\n        stats.update(summarize_k(k_gdf))\n        stats[\"k_satisfaction_5\"] = k_satisfaction(k_gdf, 5)\n        stats[\"k_satisfaction_25\"] = k_satisfaction(k_gdf, 25)\n        stats[\"k_satisfaction_50\"] = k_satisfaction(k_gdf, 50)\n    return stats\n</code></pre>"},{"location":"analysis/#maskmypy.analysis.graph_ripleyresult","title":"<code>graph_ripleyresult(result, subtitle=None)</code>","text":"<p>Generate a graph depicting a given KtestResult, such as would be generated from using <code>maskmypy.analysis.ripleys_k()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>KtestResult</code> <p>The KtestResult tuple from applying <code>maskmypy.analysis.ripleys_k()</code> on a given layer.</p> required <code>subtitle</code> <code>str</code> <p>A subtitle to add to the graph.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A matplotlib.figure.Figure object.</p> Source code in <code>maskmypy/analysis.py</code> <pre><code>def graph_ripleyresult(result: KtestResult, subtitle: str = None) -&gt; Figure:\n    \"\"\"\n    Generate a graph depicting a given KtestResult, such as would be generated from using\n    `maskmypy.analysis.ripleys_k()`.\n\n    Parameters\n    ----------\n    result : KtestResult\n        The KtestResult tuple from applying `maskmypy.analysis.ripleys_k()` on a given layer.\n    subtitle : str\n        A subtitle to add to the graph.\n\n    Returns\n    -------\n    Figure\n        A matplotlib.figure.Figure object.\n    \"\"\"\n    bounds = _bounds_from_ripleyresult(result)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(result.support, bounds, color=\"#303030\", label=\"Upper/Lower Bounds\", alpha=0.25)\n    ax.plot(result.support, result.statistic, color=\"#1f77b4\", label=\"Observed K\")\n    ax.scatter(result.support, result.statistic, c=\"#1f77b4\")\n    ax.set_xlabel(\"Distance\")\n    ax.set_ylabel(\"K Function\")\n    ax.set_title(subtitle)\n    _legend_deduped_labels(ax)\n    fig.suptitle(\"K Function Plot\")\n    return fig\n</code></pre>"},{"location":"analysis/#maskmypy.analysis.graph_ripleyresults","title":"<code>graph_ripleyresults(sensitive_result, candidate_result, subtitle=None)</code>","text":"<p>Generate a graph depicting two KtestResults, such as would be generated from using <code>maskmypy.analysis.ripleys_k()</code>.</p> <p>Similar to <code>maskmypy.analysis.graph_ripleyresult()</code> except this function graphs both the sensitive and candidate results, allowing for visual comparison of clustering and dispersion between the two.</p> <p>Parameters:</p> Name Type Description Default <code>sensitive_result</code> <code>KtestResult</code> <p>The KtestResult tuple from applying <code>maskmypy.analysis.ripleys_k()</code> on the sensitive layer.</p> required <code>candidate_result</code> <code>KtestResult</code> <p>The KtestResult tuple from applying <code>maskmypy.analysis.ripleys_k()</code> on a masked layer.</p> required <code>subtitle</code> <code>str</code> <p>A subtitle to add to the graph.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A matplotlib.figure.Figure object.</p> Source code in <code>maskmypy/analysis.py</code> <pre><code>def graph_ripleyresults(\n    sensitive_result: KtestResult,\n    candidate_result: KtestResult,\n    subtitle: str = None,\n) -&gt; Figure:\n    \"\"\"\n    Generate a graph depicting two KtestResults, such as would be generated from using\n    `maskmypy.analysis.ripleys_k()`.\n\n    Similar to `maskmypy.analysis.graph_ripleyresult()` except this function graphs both\n    the sensitive and candidate results, allowing for visual comparison of clustering and dispersion\n    between the two.\n\n    Parameters\n    ----------\n    sensitive_result : KtestResult\n        The KtestResult tuple from applying `maskmypy.analysis.ripleys_k()` on the sensitive layer.\n    candidate_result : KtestResult\n        The KtestResult tuple from applying `maskmypy.analysis.ripleys_k()` on a masked layer.\n    subtitle : str\n        A subtitle to add to the graph.\n\n    Returns\n    -------\n    Figure\n        A matplotlib.figure.Figure object.\n    \"\"\"\n    bounds = _bounds_from_ripleyresult(sensitive_result)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(\n        sensitive_result.support,\n        bounds,\n        color=\"#ff7f0e\",\n        label=\"Sensitive Upper/Lower Bounds\",\n        alpha=0.35,\n    )\n    ax.plot(\n        candidate_result.support,\n        bounds,\n        color=\"#1f77b4\",\n        label=\"Candidate Upper/Lower Bounds\",\n        alpha=0.35,\n    )\n    ax.plot(\n        sensitive_result.support,\n        sensitive_result.statistic,\n        color=\"#ff7f0e\",\n        label=\"Sensitive Statistic\",\n    )\n    ax.plot(\n        candidate_result.support,\n        candidate_result.statistic,\n        color=\"#1f77b4\",\n        label=\"Candidate Statistic\",\n    )\n    ax.scatter(sensitive_result.support, sensitive_result.statistic, zorder=6, c=\"#ff7f0e\")\n    ax.scatter(candidate_result.support, candidate_result.statistic, zorder=5, c=\"#1f77b4\")\n    ax.set_title(subtitle)\n    ax.set_xlabel(\"Distance\")\n    ax.set_ylabel(\"K Function\")\n    _legend_deduped_labels(ax)\n    fig.suptitle(\"K Function Result Comparison\")\n    return fig\n</code></pre>"},{"location":"analysis/#maskmypy.analysis.k_anonymity","title":"<code>k_anonymity(sensitive_gdf, candidate_gdf, population_gdf, population_column='pop')</code>","text":"<p>Adds a column to the <code>candidate_gdf</code> containing the spatial k-anonymity value of each masked point.</p> <p>Parameters:</p> Name Type Description Default <code>sensitive_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing sensitive points prior to masking.</p> required <code>candidate_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing masked points.</p> required <code>population_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing either address points or polygons with a population column (see <code>population_column</code>). Used to calculate k-anonymity metrics. Note that address points tend to provide more accurate results.</p> required <code>population_column</code> <code>str</code> <p>If a polygon-based <code>population_gdf</code> is provided, the name of the column containing population counts.</p> <code>'pop'</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>The <code>candidate_gdf</code> with an additional column describing k-anonymity.</p> Source code in <code>maskmypy/analysis.py</code> <pre><code>def k_anonymity(\n    sensitive_gdf: GeoDataFrame,\n    candidate_gdf: GeoDataFrame,\n    population_gdf: GeoDataFrame,\n    population_column: str = \"pop\",\n) -&gt; GeoDataFrame:\n    \"\"\"\n    Adds a column to the `candidate_gdf` containing the spatial k-anonymity value of each\n    masked point.\n\n    Parameters\n    ----------\n    sensitive_gdf : GeoDataFrame\n        A GeoDataFrame containing sensitive points prior to masking.\n    candidate_gdf : GeoDataFrame\n        A GeoDataFrame containing masked points.\n    population_gdf : GeoDataFrame\n        A GeoDataFrame containing either address points or polygons with a population column\n        (see `population_column`). Used to calculate k-anonymity metrics. Note that\n        address points tend to provide more accurate results.\n    population_column : str\n        If a polygon-based `population_gdf` is provided, the name of the column containing\n        population counts.\n\n    Returns\n    -------\n    GeoDataFrame\n        The `candidate_gdf` with an additional column describing k-anonymity.\n    \"\"\"\n    if tools._validate_geom_type(population_gdf, \"Point\"):\n        k_gdf = _calculate_k(sensitive_gdf, candidate_gdf, population_gdf)\n    elif tools._validate_geom_type(population_gdf, \"Polygon\", \"MultiPolygon\"):\n        if population_column not in population_gdf:\n            raise ValueError(\n                f\"Cannot find population column {population_column} in population_gdf\"\n            )\n        k_gdf = _estimate_k(sensitive_gdf, candidate_gdf, population_gdf, population_column)\n    else:\n        raise ValueError(\"population_gdf must include either Points or Polygons/MultiPolygons.\")\n    return k_gdf\n</code></pre>"},{"location":"analysis/#maskmypy.analysis.k_satisfaction","title":"<code>k_satisfaction(gdf, min_k, col='k_anonymity')</code>","text":"<p>For a masked GeoDataFrame containing k-anonymity values, calculate the percentage of points that are equal to or greater than (i.e. satisfy) a given k-anonymity threshold (<code>min_k</code>).</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing k-anonymity values.</p> required <code>min_k</code> <code>int</code> <p>The minimum k-anonymity that must be satisfied.</p> required <code>col</code> <code>str</code> <p>Name of the column containing k-anonymity values.</p> <code>'k_anonymity'</code> <p>Returns:</p> Type Description <code>float</code> <p>A percentage of points in the GeoDataFrame that satisfy <code>min_k</code>.</p> Source code in <code>maskmypy/analysis.py</code> <pre><code>def k_satisfaction(gdf: GeoDataFrame, min_k: int, col: str = \"k_anonymity\") -&gt; float:\n    \"\"\"\n    For a masked GeoDataFrame containing k-anonymity values, calculate the percentage of\n    points that are equal to or greater than (i.e. satisfy) a given k-anonymity threshold (`min_k`).\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        A GeoDataFrame containing k-anonymity values.\n    min_k : int\n        The minimum k-anonymity that must be satisfied.\n    col : str\n        Name of the column containing k-anonymity values.\n\n    Returns\n    -------\n    float\n        A percentage of points in the GeoDataFrame that satisfy `min_k`.\n    \"\"\"\n    return round(gdf.loc[gdf[col] &gt;= min_k, col].count() / gdf[col].count(), 3)\n</code></pre>"},{"location":"analysis/#maskmypy.analysis.map_displacement","title":"<code>map_displacement(sensitive_gdf, candidate_gdf, filename=None, context_gdf=None)</code>","text":"<p>Generate a map showing the displacement of each masked point from its original location. Requires the <code>contextily</code> package.</p> <p>Parameters:</p> Name Type Description Default <code>sensitive_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing sensitive points prior to masking.</p> required <code>candidate_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing masked points.</p> required <code>filename</code> <code>str</code> <p>If specified, saves the map to the filesystem.</p> <code>None</code> <code>context_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing contextual data to be added to the map, such as address points, administrative boundaries, etc.</p> <code>None</code> <p>Returns:</p> Type Description <code>pyplot</code> <p>A pyplot object containing the mapped data.</p> Source code in <code>maskmypy/analysis.py</code> <pre><code>def map_displacement(\n    sensitive_gdf: GeoDataFrame,\n    candidate_gdf: GeoDataFrame,\n    filename: str = None,\n    context_gdf: GeoDataFrame = None,\n) -&gt; plt:\n    \"\"\"\n    Generate a map showing the displacement of each masked point from its original location.\n    Requires the `contextily` package.\n\n    Parameters\n    ----------\n    sensitive_gdf : GeoDataFrame\n        A GeoDataFrame containing sensitive points prior to masking.\n    candidate_gdf : GeoDataFrame\n        A GeoDataFrame containing masked points.\n    filename : str\n        If specified, saves the map to the filesystem.\n    context_gdf : GeoDataFrame\n        A GeoDataFrame containing contextual data to be added to the map, such as address points,\n        administrative boundaries, etc.\n\n    Returns\n    -------\n    matplotlib.pyplot\n        A pyplot object containing the mapped data.\n    \"\"\"\n    import contextily as ctx\n\n    lines = sensitive_gdf.copy()\n    lines = lines.join(candidate_gdf, how=\"left\", rsuffix=\"_masked\")\n    lines.geometry = lines.apply(\n        lambda x: LineString([x[\"geometry\"], x[\"geometry_masked\"]]), axis=1\n    )\n    ax = lines.plot(color=\"black\", zorder=2, linewidth=1, figsize=[8, 8])\n    ax = sensitive_gdf.plot(ax=ax, color=\"red\", zorder=3, markersize=6)\n    ax = candidate_gdf.plot(ax=ax, color=\"blue\", zorder=4, markersize=6)\n    if isinstance(context_gdf, GeoDataFrame):\n        ax = context_gdf.plot(ax=ax, color=\"grey\", zorder=1, markersize=3)\n\n    ctx.add_basemap(ax, crs=sensitive_gdf.crs, source=ctx.providers.OpenStreetMap.Mapnik)\n    plt.title(\"Displacement Distances\", fontsize=16)\n    plt.figtext(\n        0.5,\n        0.025,\n        \"Sensitive points (red), Masked points (blue). \\n KEEP CONFIDENTIAL\",\n        wrap=True,\n        horizontalalignment=\"center\",\n        fontsize=12,\n    )\n    if filename:\n        plt.savefig(filename)\n\n    return plt\n</code></pre>"},{"location":"analysis/#maskmypy.analysis.nnd","title":"<code>nnd(gdf)</code>","text":"<p>Calculate the minimum, maximum, and mean nearest neighbor distance for a given GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing points.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the minimum, maximum, and mean nearest neighbor distance.</p> Source code in <code>maskmypy/analysis.py</code> <pre><code>def nnd(gdf: GeoDataFrame) -&gt; dict:\n    \"\"\"\n    Calculate the minimum, maximum, and mean nearest neighbor distance for a given GeoDataFrame.\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        A GeoDataFrame containing points.\n\n    Returns\n    -------\n    dict\n        A dictionary containing the minimum, maximum, and mean nearest neighbor distance.\n    \"\"\"\n    pp = _gdf_to_pointpattern(gdf)\n    return {\"nnd_min\": pp.min_nnd, \"nnd_max\": pp.max_nnd, \"nnd_mean\": pp.mean_nnd}\n</code></pre>"},{"location":"analysis/#maskmypy.analysis.nnd_delta","title":"<code>nnd_delta(sensitive_gdf, candidate_gdf)</code>","text":"<p>Calculate the difference between minimum, maximum, and mean nearest neighbor distances before (<code>sensitive_gdf</code>) and after (<code>candidate_gdf</code>) masking. Higher values indicate greater information loss due to masking.</p> <p>Parameters:</p> Name Type Description Default <code>sensitive_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing sensitive points prior to masking.</p> required <code>candidate_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing masked points.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary describing deltas in nearest neighbor distance before and after masking.</p> Source code in <code>maskmypy/analysis.py</code> <pre><code>def nnd_delta(sensitive_gdf: GeoDataFrame, candidate_gdf: GeoDataFrame) -&gt; dict:\n    \"\"\"\n    Calculate the *difference* between minimum, maximum, and mean nearest neighbor distances\n    before (`sensitive_gdf`) and after (`candidate_gdf`) masking. Higher values indicate\n    greater information loss due to masking.\n\n    Parameters\n    ----------\n    sensitive_gdf : GeoDataFrame\n        A GeoDataFrame containing sensitive points prior to masking.\n    candidate_gdf : GeoDataFrame\n        A GeoDataFrame containing masked points.\n\n    Returns\n    -------\n    dict\n        A dictionary describing deltas in nearest neighbor distance before and after masking.\n    \"\"\"\n    before = nnd(sensitive_gdf)\n    after = nnd(candidate_gdf)\n    delta = {}\n    for key, value in before.items():\n        delta.update({f\"{key}_delta\": round(after[key] - before[key], 6)})\n    return delta\n</code></pre>"},{"location":"analysis/#maskmypy.analysis.ripley_rmse","title":"<code>ripley_rmse(sensitive_result, candidate_result)</code>","text":"<p>Calculates the root-mean-square error between the Ripley's K-test results of unmasked and masked data. As the goal of geographic masking is to reduce information loss, the actual amount of clustering in masked data is unimportant; what matters is that the clustering or dispersion of the masked data resembles that of the original, sensitive data. By comparing the RMSE of k-test results, we can reduce this deviation to a single figure, which is useful for quickly comparing how multiple masks perform.</p> <p>Lower RMSE values indicate less information loss due to masking, whereas higher values indicate greater information loss due to masking.</p> <p>Parameters:</p> Name Type Description Default <code>sensitive_result</code> <code>KtestResult</code> <p>The KtestResult tuple from applying <code>maskmypy.analysis.ripleys_k()</code> on a sensitive layer.</p> required <code>candidate_result</code> <code>KtestResult</code> <p>The KtestResult tuple from applying <code>maskmypy.analysis.ripleys_k()</code> on a masked layer.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The root-mean-square error between the two k-test results.</p> Source code in <code>maskmypy/analysis.py</code> <pre><code>def ripley_rmse(sensitive_result: KtestResult, candidate_result: KtestResult) -&gt; float:\n    \"\"\"\n    Calculates the root-mean-square error between the Ripley's K-test results of unmasked and\n    masked data. As the goal of geographic masking is to reduce information loss, the actual\n    amount of clustering in masked data is unimportant; what matters is that the clustering\n    or dispersion of the masked data resembles that of the original, sensitive data. By comparing\n    the RMSE of k-test results, we can reduce this deviation to a single figure, which is useful\n    for quickly comparing how multiple masks perform.\n\n    Lower RMSE values indicate less information loss due to masking, whereas higher values\n    indicate greater information loss due to masking.\n\n    Parameters\n    ----------\n    sensitive_result : KtestResult\n        The KtestResult tuple from applying `maskmypy.analysis.ripleys_k()` on a sensitive layer.\n    candidate_result : KtestResult\n        The KtestResult tuple from applying `maskmypy.analysis.ripleys_k()` on a masked layer.\n\n    Returns\n    -------\n    float\n        The root-mean-square error between the two k-test results.\n    \"\"\"\n    step_count = len(candidate_result.statistic)\n    residuals = []\n    for i in range(step_count):\n        residual = candidate_result.statistic[i] - sensitive_result.statistic[i]\n        residuals.append(residual)\n    return round(sqrt(square(residuals).mean()), 3)\n</code></pre>"},{"location":"analysis/#maskmypy.analysis.ripleys_k","title":"<code>ripleys_k(gdf, max_dist=None, min_dist=None, steps=10, simulations=99)</code>","text":"<p>Performs Ripley's K clustering analysis on a GeoDataFrame. This evaluates clustering across a range of spatial scales.</p> <p>See <code>maskmypy.analysis.ripley_rmse()</code>, <code>maskmypy.analysis.graph_ripleyresult()</code>, and <code>maskmypy.analysis.graph_ripleyresults()</code> for functions that process/visualize the results of this function.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame to analyse.</p> required <code>max_dist</code> <code>float</code> <p>The largest distance band used for cluster analysis. If <code>None</code>, this defaults to one quarter of the smallest side of the bounding box (i.e. Ripleys Rule of Thumb).</p> <code>None</code> <code>min_dist</code> <code>float</code> <p>The smallest distance band used for cluster analysis. If <code>None</code>, this is automatically set to  <code>max_dist / steps</code>.</p> <code>None</code> <code>steps</code> <code>int</code> <p>The number of equally spaced intervals between the minimum and maximum distance bands to analyze clustering on.</p> <code>10</code> <code>simulations</code> <code>int</code> <p>The number of simulations to perform.</p> <code>99</code> <p>Returns:</p> Type Description <code>KtestResult</code> <p>A named tuple that contains <code>(\"support\", \"statistic\", \"pvalue\", \"simulations\")</code>.</p> Source code in <code>maskmypy/analysis.py</code> <pre><code>def ripleys_k(\n    gdf: GeoDataFrame,\n    max_dist: float = None,\n    min_dist: float = None,\n    steps: int = 10,\n    simulations: int = 99,\n) -&gt; KtestResult:\n    \"\"\"\n    Performs Ripley's K clustering analysis on a GeoDataFrame. This evaluates clustering across a\n    range of spatial scales.\n\n    See `maskmypy.analysis.ripley_rmse()`, `maskmypy.analysis.graph_ripleyresult()`, and\n    `maskmypy.analysis.graph_ripleyresults()` for functions that process/visualize the results\n    of this function.\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        GeoDataFrame to analyse.\n    max_dist : float\n        The largest distance band used for cluster analysis. If `None`, this defaults to one\n        quarter of the smallest side of the bounding box (i.e. Ripleys Rule of Thumb).\n    min_dist : float\n        The smallest distance band used for cluster analysis. If `None`, this is automatically set\n        to  `max_dist / steps`.\n    steps : int\n        The number of equally spaced intervals between the minimum and maximum distance bands\n        to analyze clustering on.\n    simulations : int\n        The number of simulations to perform.\n\n    Returns\n    -------\n    KtestResult\n        A named tuple that contains `(\"support\", \"statistic\", \"pvalue\", \"simulations\")`.\n    \"\"\"\n    if not max_dist:\n        max_dist = _gdf_to_pointpattern(gdf).rot\n\n    if not min_dist:\n        min_dist = max_dist / steps\n\n    k_results = k_test(\n        array(list(zip(gdf.geometry.x, gdf.geometry.y))),\n        keep_simulations=True,\n        support=(min_dist, max_dist, steps),\n        n_simulations=simulations,\n    )\n    return k_results\n</code></pre>"},{"location":"analysis/#maskmypy.analysis.summarize_displacement","title":"<code>summarize_displacement(gdf, col='_distance')</code>","text":"<p>For a masked GeoDataFrame containing displacement distances, calculate the minimum, maximum, median, and mean displacement distance.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing displacement distance values.</p> required <code>col</code> <code>str</code> <p>Name of the column containing displacement distance values.</p> <code>'_distance'</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing summary displacement distance statistics.</p> Source code in <code>maskmypy/analysis.py</code> <pre><code>def summarize_displacement(gdf: GeoDataFrame, col: str = \"_distance\") -&gt; dict:\n    \"\"\"\n    For a masked GeoDataFrame containing displacement distances, calculate the minimum, maximum,\n    median, and mean displacement distance.\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        A GeoDataFrame containing displacement distance values.\n    col : str\n        Name of the column containing displacement distance values.\n\n    Returns\n    -------\n    dict\n        A dictionary containing summary displacement distance statistics.\n    \"\"\"\n    return {\n        \"displacement_min\": round(float(gdf.loc[:, col].min()), 6),\n        \"displacement_max\": round(float(gdf.loc[:, col].max()), 6),\n        \"displacement_med\": round(float(gdf.loc[:, col].median()), 6),\n        \"displacement_mean\": round(float(gdf.loc[:, col].mean()), 6),\n    }\n</code></pre>"},{"location":"analysis/#maskmypy.analysis.summarize_k","title":"<code>summarize_k(gdf, col='k_anonymity')</code>","text":"<p>For a masked GeoDataFrame containing k-anonymity values, calculate the minimum, maximum, median, and mean k-anonymity.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing k-anonymity values.</p> required <code>col</code> <code>str</code> <p>Name of the column containing k-anonymity values.</p> <code>'k_anonymity'</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing summary k-anonymity statistics.</p> Source code in <code>maskmypy/analysis.py</code> <pre><code>def summarize_k(gdf: GeoDataFrame, col: str = \"k_anonymity\") -&gt; dict:\n    \"\"\"\n    For a masked GeoDataFrame containing k-anonymity values, calculate the minimum, maximum,\n    median, and mean k-anonymity.\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        A GeoDataFrame containing k-anonymity values.\n    col : str\n        Name of the column containing k-anonymity values.\n\n    Returns\n    -------\n    dict\n        A dictionary containing summary k-anonymity statistics.\n    \"\"\"\n    return {\n        \"k_min\": int(gdf.loc[:, col].min()),\n        \"k_max\": int(gdf.loc[:, col].max()),\n        \"k_med\": round(float(gdf.loc[:, col].median()), 2),\n        \"k_mean\": round(float(gdf.loc[:, col].mean()), 2),\n    }\n</code></pre>"},{"location":"atlas/","title":"Atlas","text":""},{"location":"atlas/#introduction","title":"Introduction","text":"<p>The <code>Atlas()</code> class makes it easy to both mask datasets and evaluate new masks. It acts as a type of manager that allows you to quickly test any number of combinations of masks and their associated parameters, automatically performing the evaluation for you and keeping track of the results. </p>"},{"location":"atlas/#candidates","title":"Candidates","text":"<p>When the Atlas executes a given mask, the result is referred to as a 'candidate'. Each candidate is a simple Python dictionary stored in a ordinary list at <code>Atlas.candidates[]</code>. You can also access the candidate list by slicing the Atlas itself, e.g. <code>Atlas[2]</code></p> <p>The structure of a candidate is as follows:</p> <pre><code>{\n  mask: str, # Name of the mask callable used to create the candidate\n  kwargs: dict, # Dictionary containing the keyword arguments used to create the candidate\n  checksum: str, # Checksum of the candidate GeoDataFrame\n  stats: { # Dictionary containing statistics describing information loss and privacy protection\n    \"central_drift\": float,\n    \"displacement_min\": float,\n    \"displacement_max\": float,\n    \"displacement_med\": float,\n    \"displacement_mean\": float,\n    \"nnd_min_delta\": float,\n    \"nnd_max_delta\": float,\n    \"nnd_mean_delta\": float,\n    \"ripley_rmse\": float,\n    \"k_min\": int,\n    \"k_max\": int,\n    \"k_med\": float,\n    \"k_mean\": float,\n    \"k_satisfaction_5\": float,\n    \"k_satisfaction_25\": float,\n    \"k_satisfaction_50\": float,\n  },\n}\n</code></pre>"},{"location":"atlas/#using-custom-masks","title":"Using Custom Masks","text":"<p>The Atlas can utilize custom masking functions passed to <code>Atlas.mask()</code> so long as they meet the following requirements: </p> <ul> <li>The first argument is a GeoDataFrame of sensitive points,</li> <li>They return a masked GeoDataFrame in the same CRS as the input,</li> <li>All other arguments are specified as keyword arguments (kwargs),</li> <li>When a <code>seed</code> argument is provided, outputs are reproducible.</li> </ul>"},{"location":"atlas/#reference","title":"Reference","text":""},{"location":"atlas/#maskmypy.Atlas","title":"<code>maskmypy.Atlas</code>  <code>dataclass</code>","text":"<p>A class for quickly performing and evaluating geographic masks.</p> Example <pre><code>from maskmypy import Atlas, donut, locationswap\n\natlas = Atlas(sensitive=some_points, population=some_addresses)\natlas.mask(donut, low=50, high=500)\natlas.mask(locationswap, low=50, high=500, address=some_addresses)\natlas.as_df()\n</code></pre> <p>Attributes:</p> Name Type Description <code>sensitive</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing sensitive points.</p> <code>population</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing population information, such as address points or polygon with population counts.</p> <code>population_column</code> <code>str</code> <p>If the population layer is based on polygons, the name of the column containing population counts.</p> <code>candidates</code> <code>list[]</code> <p>A list of existing masked candidates, if any.</p> Source code in <code>maskmypy/atlas.py</code> <pre><code>@dataclass\nclass Atlas:\n    \"\"\"\n    A class for quickly performing and evaluating geographic masks.\n\n    Example\n    -------\n    ```python\n    from maskmypy import Atlas, donut, locationswap\n\n    atlas = Atlas(sensitive=some_points, population=some_addresses)\n    atlas.mask(donut, low=50, high=500)\n    atlas.mask(locationswap, low=50, high=500, address=some_addresses)\n    atlas.as_df()\n    ```\n\n    Attributes\n    ----------\n    sensitive : GeoDataFrame\n        A GeoDataFrame containing sensitive points.\n    population : GeoDataFrame\n        A GeoDataFrame containing population information, such as address points or polygon\n        with population counts.\n    population_column : str\n        If the population layer is based on polygons, the name of the column containing population\n        counts.\n    candidates : list[]\n        A list of existing masked candidates, if any.\n    \"\"\"\n\n    sensitive: GeoDataFrame\n    population: GeoDataFrame = None\n    population_column: str = \"pop\"\n    candidates: list = field(default_factory=list)\n\n    def __post_init__(self):\n        self.layers = {}\n        if isinstance(self.population, GeoDataFrame):\n            tools._validate_crs(self.sensitive.crs, self.population.crs)\n\n    def __getitem__(self, idx):\n        return self.candidates[idx]\n\n    def __setitem__(self, idx, val):\n        self.candidates[idx] = val\n\n    def __len__(self):\n        return len(self.candidates)\n\n    def add_layers(self, *gdf: GeoDataFrame):\n        \"\"\"\n        Add GeoDataFrames to the layer store (`Atlas.layers`).\n\n        When regenerating masked GeoDataFrames using `Atlas.gen_gdf()`, any context layers\n        that were used in creating the associated candidate must be present in the layer store.\n        If they are, they will be automatically found and used as needed.\n\n        Note that layers are stored according to their checksum value (see\n        `maskmypy.tools.checksum()`) to provide both deduplication and integrity\n        checking.\n\n        Parameters\n        ----------\n        gdf : GeoDataFrame\n            GeoDataFrames to be added to the layer store.\n        \"\"\"\n        for x in gdf:\n            tools._validate_crs(self.sensitive.crs, x.crs)\n            self.layers[tools.checksum(x)] = x\n\n    def mask(\n        self,\n        mask_func: Callable,\n        keep_gdf: bool = False,\n        keep_candidate: bool = True,\n        skip_slow_evaluators: bool = True,\n        measure_execution_time: bool = True,\n        measure_peak_memory: bool = False,\n        **kwargs,\n    ):\n        \"\"\"\n        Execute a given mask, analyze the result, and add it to the Atlas.\n\n        Parameters\n        ----------\n        mask_func : GeoDataFrame\n            A masking function to apply to the sensitive point dataset. If using a custom mask,\n            it must take the sensitive GeoDataFrame as its first argument, all other arguments as\n            keyword arguments, and must return a GeoDataFrame containing the results.\n        keep_gdf : bool\n            If `False`, the resulting GeoDataFrame will be analyzed and then dropped to save memory.\n            Use `gen_gdf` to regenerate the GeoDataFrame.\n        keep_candidate : bool\n            If `True`, a dictionary containing mask parameters and analysis results are added to\n            the candidate list (`Atlas.candidates`, or `Atlas[index]`).\n        skip_slow_evaluators : bool\n            If `True`, skips any analyses that are known to be slow during mask result\n            evaluation. See maskmypy.analysis.evaluate() for more information.\n        measure_execution_time : bool\n            If `True`, measures the execution time of the mask function and adds it to the\n            candidate statistics. Mutually exclusive with `measure_peak_memory`\n        measure_peak_memory : bool\n            If `True`, will profile memory usage while the mask function is being applied,\n            and will add the value in MB to the candidate statistics. Note that the reported\n            value represents *additional* memory used by the mask, and does not include existing\n            allocations. Mutually exclusive with `measure_peak_memory`.\n\n            Warning: this can significantly slow down execution time.\n\n        \"\"\"\n        if measure_execution_time and measure_peak_memory:\n            raise ValueError(\n                \"`measure_execution_time` and `measure_peak_memory` cannot both be true.\"\n            )\n\n        candidate = {\n            \"mask\": mask_func.__name__,\n            \"kwargs\": self._hydrate_mask_kwargs(**kwargs),\n        }\n\n        if \"seed\" in inspect.getfullargspec(mask_func).args and \"seed\" not in candidate[\"kwargs\"]:\n            candidate[\"kwargs\"][\"seed\"] = tools.gen_seed()\n\n        if measure_execution_time:\n            time_start = default_timer()\n        elif measure_peak_memory:\n            tracemalloc.start()\n\n        gdf = mask_func(self.sensitive, **candidate[\"kwargs\"])\n\n        if measure_execution_time:\n            execution_time = default_timer() - time_start\n        elif measure_peak_memory:\n            _, mem_peak = tracemalloc.get_traced_memory()\n            tracemalloc.stop()\n            mem_peak_mb = mem_peak / 1024 / 1024\n\n        candidate[\"checksum\"] = tools.checksum(gdf)\n        candidate[\"kwargs\"] = self._dehydrate_mask_kwargs(**candidate[\"kwargs\"])\n        candidate[\"stats\"] = analysis.evaluate(\n            sensitive_gdf=self.sensitive,\n            candidate_gdf=gdf,\n            population_gdf=self.population,\n            population_column=self.population_column,\n            skip_slow=skip_slow_evaluators,\n        )\n\n        if \"UNMASKED\" in gdf.columns:\n            candidate[\"stats\"][\"UNMASKED_POINTS\"] = gdf[\"UNMASKED\"].sum()\n\n        if measure_execution_time:\n            candidate[\"stats\"][\"execution_time\"] = round(execution_time, 3)\n        elif measure_peak_memory:\n            candidate[\"stats\"][\"memory_peak_mb\"] = round(mem_peak_mb, 3)\n\n        if keep_gdf:\n            self.layers[candidate[\"checksum\"]] = gdf\n        else:\n            del gdf\n\n        if keep_candidate:\n            self.candidates.append(candidate)\n\n        return candidate\n\n    def gen_gdf(\n        self,\n        idx: int = None,\n        checksum: str = None,\n        keep: bool = False,\n        custom_mask: Callable = None,\n    ):\n        \"\"\"\n        Regenerates the GeoDataFrame for a given candidate based on either its position in the\n        `Atlas.candidates` list or its checksum.\n\n        Parameters\n        ----------\n        idx : int\n            Index of the candidate in `Atlas.candidates` to regenerate a GeoDataFrame for.\n        checksum : str\n            Checksum of the candidate in `Atlas.candidates` to regenerate a GeoDataFrame for.\n        keep : bool\n            If `True`, return the masked GeoDataFrame and store it in `Atlas.layers` for future\n            use so it does not need to be regenerated.\n        custom_mask : Callable\n            If the candidate was generated using a custom masking function from outside MaskMyPy,\n            provide the function here.\n\n        \"\"\"\n        if (idx is None and checksum is None) or (idx is not None and checksum is not None):\n            raise ValueError(f\"Must specify either idx or checksum.\")\n\n        checksum_before = checksum if checksum else self.candidates[idx][\"checksum\"]\n\n        # Check if layer is already in the store.\n        if isinstance(self.layers.get(checksum_before, None), GeoDataFrame):\n            return self.layers[checksum_before]\n\n        try:\n            candidate = next(\n                cand for cand in self.candidates if cand[\"checksum\"] == checksum_before\n            )\n        except:\n            raise ValueError(f\"Could not locate candidate with checksum '{checksum_before}'\")\n\n        mask_func = custom_mask or getattr(masks, candidate[\"mask\"])\n\n        candidate_after = self.mask(\n            mask_func, keep_candidate=False, keep_gdf=True, **candidate[\"kwargs\"]\n        )\n\n        checksum_after = candidate_after.get(\"checksum\")\n        if checksum_before != checksum_after:\n            raise ValueError(\n                f\"Checksum of masked GeoDataFrame ({checksum_after}) does not match that which is on record for this candidate ({checksum_before}). Did any input layers get modified?\"\n            )\n\n        gdf = self.layers[checksum_after]\n\n        if not keep:\n            del self.layers[checksum_after]\n\n        return gdf\n\n    def sort(self, by: str, desc: bool = False):\n        \"\"\"\n        Sorts the list of candidates (`Atlas.candidates`) based on a given statistic.\n\n        Example:\n        ```\n        # Sort candidate list in ascending order based on maximum displacement distance.\n        atlas.sort(by=\"displacement_max\")\n\n        # Sort candidate list in descending order based on minimum k-anonymity.\n        atlas.sort(by=\"k_min\", desc=True)\n        ```\n\n        Parameters\n        ----------\n        by : str\n            Name of the statistic to sort by.\n        desc : bool\n            If `True`, sort in descending order.\n\n        \"\"\"\n        if by in self.candidates[0][\"stats\"].keys():\n            self.candidates.sort(key=lambda x: x[\"stats\"][by], reverse=desc)\n        else:\n            raise ValueError(f\"Could not find '{by}' in candidate statistics.\")\n\n    def prune(self, by: str, min: float, max: float):\n        \"\"\"\n        Prune candidates based on a given statistic. If the value for that attribute is less than\n        `min` or greater than `max` (both inclusive), drop the candidate.\n\n        Example:\n        ```\n        # Prune any candidates with a minimum displacement distance below 50 and above 500.\n        atlas.prune(by=\"displacement_min\", min=50, max=500)\n\n        # Prune any candidates with minimum k-anonymity values below 10 and above 50.\n        atlas.prune(by=\"k_min\", min=10, max=50)\n        ```\n\n        Parameters\n        ----------\n        by : str\n            Name of the candidate statistic to prune by.\n        min : float\n            Minimum value of the statistic. If below `min`, the candidate is pruned from the\n            candidates list. If the statistic is equal to or greater than `min` but not\n            greater than `max` it is kept in the list.\n        max : float\n            Maximum value of the statistic. If above `max`, the candidate is pruned from the\n            candidates list. If the statistic is equal to or less than `max` but not less\n            than `min` it is kept in the list.\n        \"\"\"\n        if by in self.candidates[0][\"stats\"].keys():\n            self.candidates = [\n                c for c in self.candidates if c[\"stats\"][by] &gt;= min and c[\"stats\"][by] &lt;= max\n            ]\n        else:\n            raise ValueError(f\"Could not find '{by}' in candidate statistics.\")\n\n    def to_json(self, file: Path):\n        \"\"\"\n        Saves candidates to a JSON file. As long as the input GeoDataFrames are\n        also preserved by the user*, this JSON file can be used to later reconstruct\n        the atlas using `Atlas.from_json()`, including all resulting candidate GeoDataFrames.\n\n        * Warning: if Street masking is used, there is a chance that a candidate will not be able\n        to be regenerated if OpenStreetMap data changes. This will be addressed in a future version\n        of MaskMyPy.\n\n        Parameters\n        ----------\n        file : Path\n            File path indicating where the JSON file should be saved.\n        \"\"\"\n        with open(file, \"w\") as f:\n            json.dump(self.candidates, f)\n\n    @classmethod\n    def from_json(\n        cls,\n        sensitive: GeoDataFrame,\n        candidate_json: Path,\n        population: GeoDataFrame = None,\n        population_column: str = \"pop\",\n        layers: list = None,\n    ):\n        \"\"\"\n        Recreate an Atlas from a candidate JSON file previously generated using `Atlas.to_json()`\n        as well as the original GeoDataFrames. Masked GeoDataFrames can then be regenerated using\n        `Atlas.gen_gdf()`.\n\n        * Warning: if Street masking is used, there is a chance that a candidate will not be able\n        to be regenerated if OpenStreetMap data changes. This will be addressed in a future version\n        of MaskMyPy.\n\n        Parameters\n        ----------\n        sensitive : GeoDataFrame\n            The original sensitive point layer.\n        candidate_json : Path\n            Path to a candidate JSON file previously generated using `Atlas.to_json()`.\n        population : GeoDataFrame\n            The original population layer, if one was specified.\n        population_column : str\n            If a polygon-based population layer was used, the name of the population column.\n        layers : List[GeoDataFrame]\n            A list of additional GeoDataFrames used in the original Atlas. For instance,\n            any containers used during donut masking.\n        \"\"\"\n        with open(candidate_json) as f:\n            candidates = json.load(f)\n\n        atlas = cls(\n            sensitive=sensitive,\n            candidates=candidates,\n            population=population,\n            population_column=population_column,\n        )\n        if layers:\n            atlas.add_layers(*layers)\n        return atlas\n\n    def as_df(self):\n        \"\"\"\n        Return a pandas DataFrame describing each candidate.\n        \"\"\"\n        df = DataFrame(data=self.candidates)\n        df = concat([df.drop([\"kwargs\"], axis=1), df[\"kwargs\"].apply(Series)], axis=1)\n        df = concat([df.drop([\"stats\"], axis=1), df[\"stats\"].apply(Series)], axis=1)\n        return df\n\n    def scatter(self, a: str, b: str):\n        \"\"\"\n        Return a scatter plot of candidates across two given statistics.\n\n        Parameters\n        ----------\n        a : string\n            Name of the candidate statistic to plot.\n        b : string\n            Name of the candidate statistic to plot.\n        \"\"\"\n        df = self.as_df()\n        fig = plt.figure()\n        ax = fig.add_subplot(111)\n        ax.scatter(df[a], df[b], c=\"#1f77b4\")\n        ax.set_xlabel(a)\n        ax.set_ylabel(b)\n        for i, label in enumerate(df[\"checksum\"]):\n            ax.annotate(label, (df.loc[i, a], df.loc[i, b]))\n        return fig\n\n    def _hydrate_mask_kwargs(self, **mask_kwargs: dict) -&gt; dict:\n        \"\"\"\n        Find any keyword arguments that contain context layer checksums and\n        attempt to restore the layer from `Atlas.layers`.\n        \"\"\"\n        for key, value in mask_kwargs.items():\n            if isinstance(value, str) and value.startswith(\"context_\"):\n                checksum = value.split(\"_\")[1]\n                try:\n                    mask_kwargs[key] = self.layers[checksum]\n                except KeyError as e:\n                    raise KeyError(\n                        f\"Error: cannot find context layer for '{key}, {checksum}', \\\n                        try loading it first using Atlas.add_layers(). {e}\"\n                    )\n        return mask_kwargs\n\n    def _dehydrate_mask_kwargs(self, **mask_kwargs: dict) -&gt; dict:\n        \"\"\"\n        Search mask kwargs for any GeoDataFrames and replace them with their checksums.\n        \"\"\"\n        for key, value in mask_kwargs.items():\n            if isinstance(value, GeoDataFrame):\n                self.add_layers(value)\n                mask_kwargs[key] = \"_\".join([\"context\", tools.checksum(value)])\n        return mask_kwargs\n</code></pre>"},{"location":"atlas/#maskmypy.Atlas.add_layers","title":"<code>add_layers(*gdf)</code>","text":"<p>Add GeoDataFrames to the layer store (<code>Atlas.layers</code>).</p> <p>When regenerating masked GeoDataFrames using <code>Atlas.gen_gdf()</code>, any context layers that were used in creating the associated candidate must be present in the layer store. If they are, they will be automatically found and used as needed.</p> <p>Note that layers are stored according to their checksum value (see <code>maskmypy.tools.checksum()</code>) to provide both deduplication and integrity checking.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrames to be added to the layer store.</p> <code>()</code> Source code in <code>maskmypy/atlas.py</code> <pre><code>def add_layers(self, *gdf: GeoDataFrame):\n    \"\"\"\n    Add GeoDataFrames to the layer store (`Atlas.layers`).\n\n    When regenerating masked GeoDataFrames using `Atlas.gen_gdf()`, any context layers\n    that were used in creating the associated candidate must be present in the layer store.\n    If they are, they will be automatically found and used as needed.\n\n    Note that layers are stored according to their checksum value (see\n    `maskmypy.tools.checksum()`) to provide both deduplication and integrity\n    checking.\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        GeoDataFrames to be added to the layer store.\n    \"\"\"\n    for x in gdf:\n        tools._validate_crs(self.sensitive.crs, x.crs)\n        self.layers[tools.checksum(x)] = x\n</code></pre>"},{"location":"atlas/#maskmypy.Atlas.as_df","title":"<code>as_df()</code>","text":"<p>Return a pandas DataFrame describing each candidate.</p> Source code in <code>maskmypy/atlas.py</code> <pre><code>def as_df(self):\n    \"\"\"\n    Return a pandas DataFrame describing each candidate.\n    \"\"\"\n    df = DataFrame(data=self.candidates)\n    df = concat([df.drop([\"kwargs\"], axis=1), df[\"kwargs\"].apply(Series)], axis=1)\n    df = concat([df.drop([\"stats\"], axis=1), df[\"stats\"].apply(Series)], axis=1)\n    return df\n</code></pre>"},{"location":"atlas/#maskmypy.Atlas.from_json","title":"<code>from_json(sensitive, candidate_json, population=None, population_column='pop', layers=None)</code>  <code>classmethod</code>","text":"<p>Recreate an Atlas from a candidate JSON file previously generated using <code>Atlas.to_json()</code> as well as the original GeoDataFrames. Masked GeoDataFrames can then be regenerated using <code>Atlas.gen_gdf()</code>.</p> <ul> <li>Warning: if Street masking is used, there is a chance that a candidate will not be able to be regenerated if OpenStreetMap data changes. This will be addressed in a future version of MaskMyPy.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>sensitive</code> <code>GeoDataFrame</code> <p>The original sensitive point layer.</p> required <code>candidate_json</code> <code>Path</code> <p>Path to a candidate JSON file previously generated using <code>Atlas.to_json()</code>.</p> required <code>population</code> <code>GeoDataFrame</code> <p>The original population layer, if one was specified.</p> <code>None</code> <code>population_column</code> <code>str</code> <p>If a polygon-based population layer was used, the name of the population column.</p> <code>'pop'</code> <code>layers</code> <code>List[GeoDataFrame]</code> <p>A list of additional GeoDataFrames used in the original Atlas. For instance, any containers used during donut masking.</p> <code>None</code> Source code in <code>maskmypy/atlas.py</code> <pre><code>@classmethod\ndef from_json(\n    cls,\n    sensitive: GeoDataFrame,\n    candidate_json: Path,\n    population: GeoDataFrame = None,\n    population_column: str = \"pop\",\n    layers: list = None,\n):\n    \"\"\"\n    Recreate an Atlas from a candidate JSON file previously generated using `Atlas.to_json()`\n    as well as the original GeoDataFrames. Masked GeoDataFrames can then be regenerated using\n    `Atlas.gen_gdf()`.\n\n    * Warning: if Street masking is used, there is a chance that a candidate will not be able\n    to be regenerated if OpenStreetMap data changes. This will be addressed in a future version\n    of MaskMyPy.\n\n    Parameters\n    ----------\n    sensitive : GeoDataFrame\n        The original sensitive point layer.\n    candidate_json : Path\n        Path to a candidate JSON file previously generated using `Atlas.to_json()`.\n    population : GeoDataFrame\n        The original population layer, if one was specified.\n    population_column : str\n        If a polygon-based population layer was used, the name of the population column.\n    layers : List[GeoDataFrame]\n        A list of additional GeoDataFrames used in the original Atlas. For instance,\n        any containers used during donut masking.\n    \"\"\"\n    with open(candidate_json) as f:\n        candidates = json.load(f)\n\n    atlas = cls(\n        sensitive=sensitive,\n        candidates=candidates,\n        population=population,\n        population_column=population_column,\n    )\n    if layers:\n        atlas.add_layers(*layers)\n    return atlas\n</code></pre>"},{"location":"atlas/#maskmypy.Atlas.gen_gdf","title":"<code>gen_gdf(idx=None, checksum=None, keep=False, custom_mask=None)</code>","text":"<p>Regenerates the GeoDataFrame for a given candidate based on either its position in the <code>Atlas.candidates</code> list or its checksum.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index of the candidate in <code>Atlas.candidates</code> to regenerate a GeoDataFrame for.</p> <code>None</code> <code>checksum</code> <code>str</code> <p>Checksum of the candidate in <code>Atlas.candidates</code> to regenerate a GeoDataFrame for.</p> <code>None</code> <code>keep</code> <code>bool</code> <p>If <code>True</code>, return the masked GeoDataFrame and store it in <code>Atlas.layers</code> for future use so it does not need to be regenerated.</p> <code>False</code> <code>custom_mask</code> <code>Callable</code> <p>If the candidate was generated using a custom masking function from outside MaskMyPy, provide the function here.</p> <code>None</code> Source code in <code>maskmypy/atlas.py</code> <pre><code>def gen_gdf(\n    self,\n    idx: int = None,\n    checksum: str = None,\n    keep: bool = False,\n    custom_mask: Callable = None,\n):\n    \"\"\"\n    Regenerates the GeoDataFrame for a given candidate based on either its position in the\n    `Atlas.candidates` list or its checksum.\n\n    Parameters\n    ----------\n    idx : int\n        Index of the candidate in `Atlas.candidates` to regenerate a GeoDataFrame for.\n    checksum : str\n        Checksum of the candidate in `Atlas.candidates` to regenerate a GeoDataFrame for.\n    keep : bool\n        If `True`, return the masked GeoDataFrame and store it in `Atlas.layers` for future\n        use so it does not need to be regenerated.\n    custom_mask : Callable\n        If the candidate was generated using a custom masking function from outside MaskMyPy,\n        provide the function here.\n\n    \"\"\"\n    if (idx is None and checksum is None) or (idx is not None and checksum is not None):\n        raise ValueError(f\"Must specify either idx or checksum.\")\n\n    checksum_before = checksum if checksum else self.candidates[idx][\"checksum\"]\n\n    # Check if layer is already in the store.\n    if isinstance(self.layers.get(checksum_before, None), GeoDataFrame):\n        return self.layers[checksum_before]\n\n    try:\n        candidate = next(\n            cand for cand in self.candidates if cand[\"checksum\"] == checksum_before\n        )\n    except:\n        raise ValueError(f\"Could not locate candidate with checksum '{checksum_before}'\")\n\n    mask_func = custom_mask or getattr(masks, candidate[\"mask\"])\n\n    candidate_after = self.mask(\n        mask_func, keep_candidate=False, keep_gdf=True, **candidate[\"kwargs\"]\n    )\n\n    checksum_after = candidate_after.get(\"checksum\")\n    if checksum_before != checksum_after:\n        raise ValueError(\n            f\"Checksum of masked GeoDataFrame ({checksum_after}) does not match that which is on record for this candidate ({checksum_before}). Did any input layers get modified?\"\n        )\n\n    gdf = self.layers[checksum_after]\n\n    if not keep:\n        del self.layers[checksum_after]\n\n    return gdf\n</code></pre>"},{"location":"atlas/#maskmypy.Atlas.mask","title":"<code>mask(mask_func, keep_gdf=False, keep_candidate=True, skip_slow_evaluators=True, measure_execution_time=True, measure_peak_memory=False, **kwargs)</code>","text":"<p>Execute a given mask, analyze the result, and add it to the Atlas.</p> <p>Parameters:</p> Name Type Description Default <code>mask_func</code> <code>GeoDataFrame</code> <p>A masking function to apply to the sensitive point dataset. If using a custom mask, it must take the sensitive GeoDataFrame as its first argument, all other arguments as keyword arguments, and must return a GeoDataFrame containing the results.</p> required <code>keep_gdf</code> <code>bool</code> <p>If <code>False</code>, the resulting GeoDataFrame will be analyzed and then dropped to save memory. Use <code>gen_gdf</code> to regenerate the GeoDataFrame.</p> <code>False</code> <code>keep_candidate</code> <code>bool</code> <p>If <code>True</code>, a dictionary containing mask parameters and analysis results are added to the candidate list (<code>Atlas.candidates</code>, or <code>Atlas[index]</code>).</p> <code>True</code> <code>skip_slow_evaluators</code> <code>bool</code> <p>If <code>True</code>, skips any analyses that are known to be slow during mask result evaluation. See maskmypy.analysis.evaluate() for more information.</p> <code>True</code> <code>measure_execution_time</code> <code>bool</code> <p>If <code>True</code>, measures the execution time of the mask function and adds it to the candidate statistics. Mutually exclusive with <code>measure_peak_memory</code></p> <code>True</code> <code>measure_peak_memory</code> <code>bool</code> <p>If <code>True</code>, will profile memory usage while the mask function is being applied, and will add the value in MB to the candidate statistics. Note that the reported value represents additional memory used by the mask, and does not include existing allocations. Mutually exclusive with <code>measure_peak_memory</code>.</p> <p>Warning: this can significantly slow down execution time.</p> <code>False</code> Source code in <code>maskmypy/atlas.py</code> <pre><code>def mask(\n    self,\n    mask_func: Callable,\n    keep_gdf: bool = False,\n    keep_candidate: bool = True,\n    skip_slow_evaluators: bool = True,\n    measure_execution_time: bool = True,\n    measure_peak_memory: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Execute a given mask, analyze the result, and add it to the Atlas.\n\n    Parameters\n    ----------\n    mask_func : GeoDataFrame\n        A masking function to apply to the sensitive point dataset. If using a custom mask,\n        it must take the sensitive GeoDataFrame as its first argument, all other arguments as\n        keyword arguments, and must return a GeoDataFrame containing the results.\n    keep_gdf : bool\n        If `False`, the resulting GeoDataFrame will be analyzed and then dropped to save memory.\n        Use `gen_gdf` to regenerate the GeoDataFrame.\n    keep_candidate : bool\n        If `True`, a dictionary containing mask parameters and analysis results are added to\n        the candidate list (`Atlas.candidates`, or `Atlas[index]`).\n    skip_slow_evaluators : bool\n        If `True`, skips any analyses that are known to be slow during mask result\n        evaluation. See maskmypy.analysis.evaluate() for more information.\n    measure_execution_time : bool\n        If `True`, measures the execution time of the mask function and adds it to the\n        candidate statistics. Mutually exclusive with `measure_peak_memory`\n    measure_peak_memory : bool\n        If `True`, will profile memory usage while the mask function is being applied,\n        and will add the value in MB to the candidate statistics. Note that the reported\n        value represents *additional* memory used by the mask, and does not include existing\n        allocations. Mutually exclusive with `measure_peak_memory`.\n\n        Warning: this can significantly slow down execution time.\n\n    \"\"\"\n    if measure_execution_time and measure_peak_memory:\n        raise ValueError(\n            \"`measure_execution_time` and `measure_peak_memory` cannot both be true.\"\n        )\n\n    candidate = {\n        \"mask\": mask_func.__name__,\n        \"kwargs\": self._hydrate_mask_kwargs(**kwargs),\n    }\n\n    if \"seed\" in inspect.getfullargspec(mask_func).args and \"seed\" not in candidate[\"kwargs\"]:\n        candidate[\"kwargs\"][\"seed\"] = tools.gen_seed()\n\n    if measure_execution_time:\n        time_start = default_timer()\n    elif measure_peak_memory:\n        tracemalloc.start()\n\n    gdf = mask_func(self.sensitive, **candidate[\"kwargs\"])\n\n    if measure_execution_time:\n        execution_time = default_timer() - time_start\n    elif measure_peak_memory:\n        _, mem_peak = tracemalloc.get_traced_memory()\n        tracemalloc.stop()\n        mem_peak_mb = mem_peak / 1024 / 1024\n\n    candidate[\"checksum\"] = tools.checksum(gdf)\n    candidate[\"kwargs\"] = self._dehydrate_mask_kwargs(**candidate[\"kwargs\"])\n    candidate[\"stats\"] = analysis.evaluate(\n        sensitive_gdf=self.sensitive,\n        candidate_gdf=gdf,\n        population_gdf=self.population,\n        population_column=self.population_column,\n        skip_slow=skip_slow_evaluators,\n    )\n\n    if \"UNMASKED\" in gdf.columns:\n        candidate[\"stats\"][\"UNMASKED_POINTS\"] = gdf[\"UNMASKED\"].sum()\n\n    if measure_execution_time:\n        candidate[\"stats\"][\"execution_time\"] = round(execution_time, 3)\n    elif measure_peak_memory:\n        candidate[\"stats\"][\"memory_peak_mb\"] = round(mem_peak_mb, 3)\n\n    if keep_gdf:\n        self.layers[candidate[\"checksum\"]] = gdf\n    else:\n        del gdf\n\n    if keep_candidate:\n        self.candidates.append(candidate)\n\n    return candidate\n</code></pre>"},{"location":"atlas/#maskmypy.Atlas.prune","title":"<code>prune(by, min, max)</code>","text":"<p>Prune candidates based on a given statistic. If the value for that attribute is less than <code>min</code> or greater than <code>max</code> (both inclusive), drop the candidate.</p> <p>Example: <pre><code># Prune any candidates with a minimum displacement distance below 50 and above 500.\natlas.prune(by=\"displacement_min\", min=50, max=500)\n\n# Prune any candidates with minimum k-anonymity values below 10 and above 50.\natlas.prune(by=\"k_min\", min=10, max=50)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str</code> <p>Name of the candidate statistic to prune by.</p> required <code>min</code> <code>float</code> <p>Minimum value of the statistic. If below <code>min</code>, the candidate is pruned from the candidates list. If the statistic is equal to or greater than <code>min</code> but not greater than <code>max</code> it is kept in the list.</p> required <code>max</code> <code>float</code> <p>Maximum value of the statistic. If above <code>max</code>, the candidate is pruned from the candidates list. If the statistic is equal to or less than <code>max</code> but not less than <code>min</code> it is kept in the list.</p> required Source code in <code>maskmypy/atlas.py</code> <pre><code>def prune(self, by: str, min: float, max: float):\n    \"\"\"\n    Prune candidates based on a given statistic. If the value for that attribute is less than\n    `min` or greater than `max` (both inclusive), drop the candidate.\n\n    Example:\n    ```\n    # Prune any candidates with a minimum displacement distance below 50 and above 500.\n    atlas.prune(by=\"displacement_min\", min=50, max=500)\n\n    # Prune any candidates with minimum k-anonymity values below 10 and above 50.\n    atlas.prune(by=\"k_min\", min=10, max=50)\n    ```\n\n    Parameters\n    ----------\n    by : str\n        Name of the candidate statistic to prune by.\n    min : float\n        Minimum value of the statistic. If below `min`, the candidate is pruned from the\n        candidates list. If the statistic is equal to or greater than `min` but not\n        greater than `max` it is kept in the list.\n    max : float\n        Maximum value of the statistic. If above `max`, the candidate is pruned from the\n        candidates list. If the statistic is equal to or less than `max` but not less\n        than `min` it is kept in the list.\n    \"\"\"\n    if by in self.candidates[0][\"stats\"].keys():\n        self.candidates = [\n            c for c in self.candidates if c[\"stats\"][by] &gt;= min and c[\"stats\"][by] &lt;= max\n        ]\n    else:\n        raise ValueError(f\"Could not find '{by}' in candidate statistics.\")\n</code></pre>"},{"location":"atlas/#maskmypy.Atlas.scatter","title":"<code>scatter(a, b)</code>","text":"<p>Return a scatter plot of candidates across two given statistics.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>string</code> <p>Name of the candidate statistic to plot.</p> required <code>b</code> <code>string</code> <p>Name of the candidate statistic to plot.</p> required Source code in <code>maskmypy/atlas.py</code> <pre><code>def scatter(self, a: str, b: str):\n    \"\"\"\n    Return a scatter plot of candidates across two given statistics.\n\n    Parameters\n    ----------\n    a : string\n        Name of the candidate statistic to plot.\n    b : string\n        Name of the candidate statistic to plot.\n    \"\"\"\n    df = self.as_df()\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.scatter(df[a], df[b], c=\"#1f77b4\")\n    ax.set_xlabel(a)\n    ax.set_ylabel(b)\n    for i, label in enumerate(df[\"checksum\"]):\n        ax.annotate(label, (df.loc[i, a], df.loc[i, b]))\n    return fig\n</code></pre>"},{"location":"atlas/#maskmypy.Atlas.sort","title":"<code>sort(by, desc=False)</code>","text":"<p>Sorts the list of candidates (<code>Atlas.candidates</code>) based on a given statistic.</p> <p>Example: <pre><code># Sort candidate list in ascending order based on maximum displacement distance.\natlas.sort(by=\"displacement_max\")\n\n# Sort candidate list in descending order based on minimum k-anonymity.\natlas.sort(by=\"k_min\", desc=True)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str</code> <p>Name of the statistic to sort by.</p> required <code>desc</code> <code>bool</code> <p>If <code>True</code>, sort in descending order.</p> <code>False</code> Source code in <code>maskmypy/atlas.py</code> <pre><code>def sort(self, by: str, desc: bool = False):\n    \"\"\"\n    Sorts the list of candidates (`Atlas.candidates`) based on a given statistic.\n\n    Example:\n    ```\n    # Sort candidate list in ascending order based on maximum displacement distance.\n    atlas.sort(by=\"displacement_max\")\n\n    # Sort candidate list in descending order based on minimum k-anonymity.\n    atlas.sort(by=\"k_min\", desc=True)\n    ```\n\n    Parameters\n    ----------\n    by : str\n        Name of the statistic to sort by.\n    desc : bool\n        If `True`, sort in descending order.\n\n    \"\"\"\n    if by in self.candidates[0][\"stats\"].keys():\n        self.candidates.sort(key=lambda x: x[\"stats\"][by], reverse=desc)\n    else:\n        raise ValueError(f\"Could not find '{by}' in candidate statistics.\")\n</code></pre>"},{"location":"atlas/#maskmypy.Atlas.to_json","title":"<code>to_json(file)</code>","text":"<p>Saves candidates to a JSON file. As long as the input GeoDataFrames are also preserved by the user*, this JSON file can be used to later reconstruct the atlas using <code>Atlas.from_json()</code>, including all resulting candidate GeoDataFrames.</p> <ul> <li>Warning: if Street masking is used, there is a chance that a candidate will not be able to be regenerated if OpenStreetMap data changes. This will be addressed in a future version of MaskMyPy.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>File path indicating where the JSON file should be saved.</p> required Source code in <code>maskmypy/atlas.py</code> <pre><code>def to_json(self, file: Path):\n    \"\"\"\n    Saves candidates to a JSON file. As long as the input GeoDataFrames are\n    also preserved by the user*, this JSON file can be used to later reconstruct\n    the atlas using `Atlas.from_json()`, including all resulting candidate GeoDataFrames.\n\n    * Warning: if Street masking is used, there is a chance that a candidate will not be able\n    to be regenerated if OpenStreetMap data changes. This will be addressed in a future version\n    of MaskMyPy.\n\n    Parameters\n    ----------\n    file : Path\n        File path indicating where the JSON file should be saved.\n    \"\"\"\n    with open(file, \"w\") as f:\n        json.dump(self.candidates, f)\n</code></pre>"},{"location":"masks/","title":"Masks","text":""},{"location":"masks/#donut-masking","title":"Donut Masking","text":""},{"location":"masks/#maskmypy.donut.donut","title":"<code>donut(gdf, low, high, container=None, distribution='uniform', seed=None, snap_to_streets=False)</code>","text":"<p>Apply donut masking to a GeoDataFrame, randomly displacing points between a minimum and maximum distance. Advantages of this mask is speed and simplicity, though it does not handle highly varied population densities well.</p> Example <pre><code>from maskmypy import donut\n\nmasked = donut(\n    gdf=sensitive_points,\n    min=100,\n    max=1000\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing sensitive points.</p> required <code>low</code> <code>float</code> <p>Minimum distance to displace points. Unit must match that of the <code>gdf</code> CRS.</p> required <code>high</code> <code>float</code> <p>Maximum displacement to displace points. Unit must match that of the <code>gdf</code> CRS.</p> required <code>container</code> <code>GeoDataFrame</code> <p>A  GeoDataFrame containing polygons within which intersecting sensitive points should remain after masking. This works by masking a point, checking if it intersects the same polygon prior to masking, and retrying until it does. Useful for preserving statistical relationships, such as census tract, or to ensure that points are not displaced into impossible locations, such as the ocean. CRS must match that of <code>gdf</code>.</p> <code>None</code> <code>distribution</code> <code>str</code> <p>The distribution used to determine masking distances. <code>uniform</code> provides a flat distribution where any value between the minimum and maximum distance is equally likely to be selected. <code>areal</code> is more likely to select distances that are further away. The <code>gaussian</code> distribution uses a normal distribution, where values towards the middle of the range are most likely to be selected. Note that gaussian distribution has a small chance of selecting values beyond the defined minimum and maximum.</p> <code>'uniform'</code> <code>seed</code> <code>int</code> <p>Used to seed the random number generator so that masked datasets are reproducible. Randomly generated if left undefined.</p> <code>None</code> <code>snap_to_streets</code> <code>bool</code> <p>If True, points are snapped to the nearest node on the OSM street network after masking. This can reduce the chance of false-attribution.</p> <code>False</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame containing masked points.</p> Source code in <code>maskmypy/masks/donut.py</code> <pre><code>def donut(\n    gdf: GeoDataFrame,\n    low: float,\n    high: float,\n    container: GeoDataFrame = None,\n    distribution: str = \"uniform\",\n    seed: int = None,\n    snap_to_streets: bool = False,\n) -&gt; GeoDataFrame:\n    \"\"\"\n    Apply donut masking to a GeoDataFrame, randomly displacing points between a minimum and\n    maximum distance. Advantages of this mask is speed and simplicity, though it does not\n    handle highly varied population densities well.\n\n    Example\n    -------\n    ```python\n    from maskmypy import donut\n\n    masked = donut(\n        gdf=sensitive_points,\n        min=100,\n        max=1000\n    )\n    ```\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        GeoDataFrame containing sensitive points.\n    low : float\n        Minimum distance to displace points. Unit must match that of the `gdf` CRS.\n    high : float\n        Maximum displacement to displace points. Unit must match that of the `gdf` CRS.\n    container : GeoDataFrame\n        A  GeoDataFrame containing polygons within which intersecting sensitive points should\n        remain after masking. This works by masking a point, checking if it intersects\n        the same polygon prior to masking, and retrying until it does. Useful for preserving\n        statistical relationships, such as census tract, or to ensure that points are not\n        displaced into impossible locations, such as the ocean. CRS must match that of `gdf`.\n    distribution : str\n        The distribution used to determine masking distances. `uniform` provides\n        a flat distribution where any value between the minimum and maximum distance is\n        equally likely to be selected. `areal` is more likely to select distances that are\n        further away. The `gaussian` distribution uses a normal distribution, where values\n        towards the middle of the range are most likely to be selected. Note that gaussian\n        distribution has a small chance of selecting values beyond the defined minimum and\n        maximum.\n    seed : int\n        Used to seed the random number generator so that masked datasets are reproducible.\n        Randomly generated if left undefined.\n    snap_to_streets : bool\n        If True, points are snapped to the nearest node on the OSM street network after masking.\n        This can reduce the chance of false-attribution.\n\n    Returns\n    -------\n    GeoDataFrame\n        A GeoDataFrame containing masked points.\n    \"\"\"\n    _gdf = gdf.copy()\n    _validate_donut(_gdf, low, high, container)\n\n    seed = tools.gen_seed() if not seed else seed\n\n    args = locals()\n    del args[\"snap_to_streets\"]\n    del args[\"gdf\"]\n\n    masked_gdf = _Donut(**args).run()\n\n    if snap_to_streets:\n        masked_gdf = tools.snap_to_streets(masked_gdf)\n\n    return masked_gdf\n</code></pre>"},{"location":"masks/#street-masking","title":"Street Masking","text":""},{"location":"masks/#maskmypy.street.street","title":"<code>street(gdf, low, high, max_length=1000, seed=None, padding=0.2)</code>","text":"<p>Apply street masking to a GeoDataFrame, displacing points along the OpenStreetMap street network. This helps account for variations in population density, and reduces the likelihood of false attribution as points are always displaced to the street network. Each point is snapped to the nearest node on the network, then displaced along the surround network between <code>low</code> and <code>high</code> nodes away.</p> Example <pre><code>from maskmypy import street\n\nmasked = street(\n    gdf=sensitive_points,\n    min=20,\n    max=30\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing sensitive points.</p> required <code>low</code> <code>int</code> <p>Minimum number of nodes along the OSM street network to traverse.</p> required <code>high</code> <code>int</code> <p>Maximum number of nodes along the OSM street network to traverse.</p> required <code>max_length</code> <code>float</code> <p>When locating the closest node to each point on the street network, MaskMyPy verifies that its immediate neighbours are no more than <code>max_length</code> away, in meters. This prevents extremely large masking distances, such as those caused by long highways.</p> <code>1000</code> <code>seed</code> <code>int</code> <p>Used to seed the random number generator so that masked datasets are reproducible. Randomly generated if left undefined.</p> <code>None</code> <code>padding</code> <code>float</code> <p>OSM network data is retrieved based on the bounding box of the sensitive GeoDataFrame. Padding is used to expand this bounding box slightly to reduce unwanted edge-effects. A value of <code>0.2</code> would add 20% of the x and y extent to each side of the bounding box.</p> <code>0.2</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame containing masked points.</p> Source code in <code>maskmypy/masks/street.py</code> <pre><code>def street(\n    gdf: GeoDataFrame,\n    low: int,\n    high: int,\n    max_length: float = 1000,\n    seed: int = None,\n    padding: float = 0.2,\n) -&gt; GeoDataFrame:\n    \"\"\"\n    Apply street masking to a GeoDataFrame, displacing points along the OpenStreetMap street\n    network. This helps account for variations in population density, and reduces the likelihood\n    of false attribution as points are always displaced to the street network. Each point is\n    snapped to the nearest node on the network, then displaced along the surround network between\n    `low` and `high` nodes away.\n\n    Example\n    -------\n    ```python\n    from maskmypy import street\n\n    masked = street(\n        gdf=sensitive_points,\n        min=20,\n        max=30\n    )\n    ```\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        GeoDataFrame containing sensitive points.\n    low : int\n        Minimum number of nodes along the OSM street network to traverse.\n    high : int\n        Maximum number of nodes along the OSM street network to traverse.\n    max_length : float\n        When locating the closest node to each point on the street network, MaskMyPy verifies\n        that its immediate neighbours are no more than `max_length` away, in meters. This prevents\n        extremely large masking distances, such as those caused by long highways.\n    seed : int\n        Used to seed the random number generator so that masked datasets are reproducible.\n        Randomly generated if left undefined.\n    padding : float\n        OSM network data is retrieved based on the bounding box of the sensitive GeoDataFrame.\n        Padding is used to expand this bounding box slightly to reduce unwanted edge-effects.\n        A value of `0.2` would add 20% of the x and y extent to *each side* of the bounding box.\n\n    Returns\n    -------\n    GeoDataFrame\n        A GeoDataFrame containing masked points.\n    \"\"\"\n    _gdf = gdf.copy()\n    _validate_street(_gdf, low, high)\n\n    seed = tools.gen_seed() if not seed else seed\n\n    args = locals()\n    del args[\"gdf\"]\n\n    masked_gdf = _Street(**args).run()\n\n    return masked_gdf\n</code></pre>"},{"location":"masks/#location-swapping","title":"Location Swapping","text":""},{"location":"masks/#maskmypy.locationswap.locationswap","title":"<code>locationswap(gdf, low, high, address, seed=None, snap_to_streets=False)</code>","text":"<p>Applies location swapping to a GeoDataFrame, displacing points to a randomly selected address that is between a minimum and maximum distance away from the original point. While address data is the most common data type used to provide eligible swap locations, other point-based datasets may be used.</p> <p>Note: If a sensitive point has no address points within range, the point is displaced to (0,0).</p> Example <pre><code>from maskmypy import locationswap\n\nmasked = locationswap(\n    gdf=sensitive_points,\n    low=50,\n    high=500,\n    address=address_points\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing sensitive points.</p> required <code>low</code> <code>float</code> <p>Minimum distance to displace points. Unit must match that of the <code>gdf</code> CRS.</p> required <code>high</code> <code>float</code> <p>Maximum displacement to displace points. Unit must match that of the <code>gdf</code> CRS.</p> required <code>address</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing points that sensitive locations may be swapped to. While addresses are most common, other point-based data may be used as well.</p> required <code>seed</code> <code>int</code> <p>Used to seed the random number generator so that masked datasets are reproducible. Randomly generated if left undefined.</p> <code>None</code> <code>snap_to_streets</code> <code>bool</code> <p>If True, points are snapped to the nearest node on the OSM street network after masking. This can reduce the chance of false-attribution.</p> <code>False</code> Source code in <code>maskmypy/masks/locationswap.py</code> <pre><code>def locationswap(\n    gdf: GeoDataFrame,\n    low: float,\n    high: float,\n    address: GeoDataFrame,\n    seed: int = None,\n    snap_to_streets: bool = False,\n):\n    \"\"\"\n    Applies location swapping to a GeoDataFrame, displacing points to a randomly selected address\n    that is between a minimum and maximum distance away from the original point. While address\n    data is the most common data type used to provide eligible swap locations, other point-based\n    datasets may be used.\n\n    Note: If a sensitive point has no address points within range, the point is displaced to (0,0).\n\n    Example\n    -------\n    ```python\n    from maskmypy import locationswap\n\n    masked = locationswap(\n        gdf=sensitive_points,\n        low=50,\n        high=500,\n        address=address_points\n    )\n    ```\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        GeoDataFrame containing sensitive points.\n    low : float\n        Minimum distance to displace points. Unit must match that of the `gdf` CRS.\n    high : float\n        Maximum displacement to displace points. Unit must match that of the `gdf` CRS.\n    address : GeoDataFrame\n        GeoDataFrame containing points that sensitive locations may be swapped to.\n        While addresses are most common, other point-based data may be used as well.\n    seed : int\n        Used to seed the random number generator so that masked datasets are reproducible.\n        Randomly generated if left undefined.\n    snap_to_streets : bool\n        If True, points are snapped to the nearest node on the OSM street network after masking.\n        This can reduce the chance of false-attribution.\n    \"\"\"\n\n    _gdf = gdf.copy()\n    _validate_locationswap(_gdf, low, high, address)\n\n    seed = tools.gen_seed() if not seed else seed\n\n    args = locals()\n    del args[\"snap_to_streets\"]\n    del args[\"gdf\"]\n\n    mask = _LocationSwap(**args)\n    masked_gdf = mask.run()\n\n    if mask._unmasked_points:\n        masked_gdf = tools._mark_unmasked_points(gdf, masked_gdf)\n\n    if snap_to_streets:\n        masked_gdf = tools.snap_to_streets(masked_gdf)\n\n    return masked_gdf\n</code></pre>"},{"location":"masks/#voronoi-masking","title":"Voronoi Masking","text":""},{"location":"masks/#maskmypy.voronoi.voronoi","title":"<code>voronoi(gdf, snap_to_streets=False)</code>","text":"<p>Apply voronoi masking to a GeoDataFrame, displacing points to the nearest edges of a vornoi diagram. Note: because voronoi masking lacks any level of randomization, snapping to streets is recommended for this mask to provide another level of obfuscation.</p> Example <pre><code>from maskmypy import voronoi\n\nmasked = voronoi(\n    gdf=sensitive_points,\n    snap_to_streets=True\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing sensitive points.</p> required <code>snap_to_streets</code> <code>bool</code> <p>If True, points are snapped to the nearest node on the OSM street network after masking. This can reduce the chance of false-attribution.</p> <code>False</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame containing masked points.</p> Source code in <code>maskmypy/masks/voronoi.py</code> <pre><code>def voronoi(gdf: GeoDataFrame, snap_to_streets: bool = False) -&gt; GeoDataFrame:\n    \"\"\"\n    Apply voronoi masking to a GeoDataFrame, displacing points to the nearest edges of a vornoi\n    diagram. Note: because voronoi masking lacks any level of randomization, snapping to streets\n    is recommended for this mask to provide another level of obfuscation.\n\n    Example\n    -------\n    ```python\n    from maskmypy import voronoi\n\n    masked = voronoi(\n        gdf=sensitive_points,\n        snap_to_streets=True\n    )\n    ```\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        GeoDataFrame containing sensitive points.\n    snap_to_streets : bool\n        If True, points are snapped to the nearest node on the OSM street network after masking.\n        This can reduce the chance of false-attribution.\n\n    Returns\n    -------\n    GeoDataFrame\n        A GeoDataFrame containing masked points.\n    \"\"\"\n    _gdf = gdf.copy()\n    _validate_voronoi(gdf)\n\n    args = locals()\n    del args[\"snap_to_streets\"]\n    del args[\"gdf\"]\n\n    masked_gdf = _Voronoi(**args).run()\n\n    if snap_to_streets:\n        masked_gdf = tools.snap_to_streets(masked_gdf)\n\n    return masked_gdf\n</code></pre>"},{"location":"tools/","title":"Tools","text":""},{"location":"tools/#maskmypy.tools","title":"<code>maskmypy.tools</code>","text":""},{"location":"tools/#maskmypy.tools.checksum","title":"<code>checksum(gdf)</code>","text":"<p>Calculate SHA256 checksum of a GeoDataFrame and return the first 8 characters. Two completely identical GeoDataFrames will always return the exact same value, whereas two similar, but not completely identical GeoDataFrames will return entirely different values.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>Any valid GeoDataFrame.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The first 8 characters of the SHA256 checksum of the input GeoDataFrame.</p> Source code in <code>maskmypy/tools.py</code> <pre><code>def checksum(gdf: GeoDataFrame) -&gt; str:\n    \"\"\"\n    Calculate SHA256 checksum of a GeoDataFrame and return the first 8 characters.\n    Two completely identical GeoDataFrames will always return the exact same value,\n    whereas two similar, but not completely identical GeoDataFrames will return\n    entirely different values.\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Any valid GeoDataFrame.\n\n    Returns\n    -------\n    str\n        The first 8 characters of the SHA256 checksum of the input GeoDataFrame.\n    \"\"\"\n    return sha256(bytearray(hash_pandas_object(gdf).values)).hexdigest()[0:8]\n</code></pre>"},{"location":"tools/#maskmypy.tools.gen_rng","title":"<code>gen_rng(seed=None)</code>","text":"<p>Create a seeded numpy default_rng() object.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>An integer used to seed the random number generator. A seed is randomly generated using gen_seed() if one is not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>numpy.default_rng()</p> Source code in <code>maskmypy/tools.py</code> <pre><code>def gen_rng(seed: int = None) -&gt; object:\n    \"\"\"\n    Create a seeded numpy default_rng() object.\n\n    Parameters\n    ----------\n    seed : int\n        An integer used to seed the random number generator. A seed is randomly\n        generated using gen_seed() if one is not provided.\n    Returns\n    -------\n    object\n        numpy.default_rng()\n    \"\"\"\n    if not seed:\n        seed = gen_seed()\n    return random.default_rng(seed=seed)\n</code></pre>"},{"location":"tools/#maskmypy.tools.gen_seed","title":"<code>gen_seed()</code>","text":"<p>Generate a 16-digit random integer to seed random number generators.</p> <p>Returns:</p> Type Description <code>int</code> <p>A 16 digit random integer.</p> Source code in <code>maskmypy/tools.py</code> <pre><code>def gen_seed() -&gt; int:\n    \"\"\"\n    Generate a 16-digit random integer to seed random number generators.\n\n    Returns\n    -------\n    int\n        A 16 digit random integer.\n    \"\"\"\n\n    return int(SystemRandom().random() * (10**16))\n</code></pre>"},{"location":"tools/#maskmypy.tools.snap_to_streets","title":"<code>snap_to_streets(gdf)</code>","text":"<p>Relocates each point of a GeoDataFrame to the nearest node on the OpenStreetMap driving network. Performing this on masked datasets may reduce the chances of false attribution, and may provide an additional layer of obfuscation.</p> <p>This is not an alternative to masking.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame containing point data.</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame containing points that have been snapped to street nodes.</p> Source code in <code>maskmypy/tools.py</code> <pre><code>def snap_to_streets(gdf: GeoDataFrame) -&gt; GeoDataFrame:\n    \"\"\"\n    Relocates each point of a GeoDataFrame to the nearest node on the OpenStreetMap driving\n    network. Performing this on masked datasets may reduce the chances of false attribution,\n    and may provide an additional layer of obfuscation.\n\n    This is *not* an alternative to masking.\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        A GeoDataFrame containing point data.\n\n    Returns\n    -------\n    GeoDataFrame\n        A GeoDataFrame containing points that have been snapped to street nodes.\n    \"\"\"\n    snapped_gdf = gdf.copy()\n    bbox = gdf.to_crs(epsg=4326).total_bounds\n    graph = remove_isolated_nodes(\n        graph_from_bbox(\n            bbox=(bbox[3], bbox[1], bbox[2], bbox[0]),\n            network_type=\"drive\",\n            truncate_by_edge=True,\n        ),\n        warn=False,\n    )\n    graph = project_graph(graph, to_crs=gdf.crs)\n    node_gdf = graph_to_gdfs(graph)[0]\n\n    snapped_gdf[snapped_gdf.geometry.name] = snapped_gdf[snapped_gdf.geometry.name].apply(\n        lambda geom: node_gdf.at[nearest_nodes(graph, geom.x, geom.y), node_gdf.geometry.name]\n    )\n\n    return snapped_gdf\n</code></pre>"}]}