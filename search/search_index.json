{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python tools for anonymizing geographic data. Introduction \u00b6 MaskMyPy is a Python package that performs geographic masking on GeoDataFrames . It offers two main methods: donut masking and street masking . MaskMyPy also supports calculating metrics to help optimize and validate masking parameters. Currently, it offers k-anonymity estimation using population data, k-anonymity calculation using address data, and displacement distance calculation between sensitive and masked points. Disclaimer : MaskMyPy is offered as-is, without warranty of any kind. Geographic masking is a hard problem that requires informed decisions and validation. MaskMyPy provides helpful tools for geographic masking, but does not replace expertise. Installation \u00b6 pip install maskmypy Example \u00b6 The following snippet applies a 500 meter* donut mask to a GeoDataFrame of sensitive points: >>> from maskmypy import Donut >>> import geopandas as gpd >>> sensitive_points = gpd.read_file('sensitive_points') >>> sensitive_points CID geometry 0 1 POINT (-13703523.337 6313860.932) 1 2 POINT (-13703436.959 6314112.457) 2 3 POINT (-13703679.041 6314040.923) 3 4 POINT (-13703285.553 6313721.356) 4 5 POINT (-13703200.338 6313847.431) >>> masked_points = Donut(sensitive_points, max_distance=500).run() >>> masked_points CID geometry 0 1 POINT (-13703383.941 6313989.161) 1 2 POINT (-13703227.863 6313973.121) 2 3 POINT (-13703313.001 6314172.582) 3 4 POINT (-13703107.232 6313614.978) 4 5 POINT (-13702837.385 6314140.874) We can also calculate the distance that each points was displaced by adding the displacement=True flag to .run() : masked_points = Donut(points).run(displacement=True) masked_points CID geometry _distance 0 1 POINT (-13703383.941 6313989.161) 189.404946 1 2 POINT (-13703227.863 6313973.121) 251.267943 2 3 POINT (-13703313.001 6314172.582) 388.997713 3 4 POINT (-13703107.232 6313614.978) 207.639785 4 5 POINT (-13702837.385 6314140.874) 466.738146 * Note that the max_distance parameter assumes that the supplied distance is in the same unit as the GeoDataFrame. For example, if your GeoDataFrame is projected to a CRS that uses feet, then max_distance=500 will displace points up to 500 feet. Roadmap \u00b6 The following features are currently planned: Location Swapping/Verified Neighbor masks Automatic plotting of point displacement The ability to save mask metadata","title":"Home"},{"location":"#introduction","text":"MaskMyPy is a Python package that performs geographic masking on GeoDataFrames . It offers two main methods: donut masking and street masking . MaskMyPy also supports calculating metrics to help optimize and validate masking parameters. Currently, it offers k-anonymity estimation using population data, k-anonymity calculation using address data, and displacement distance calculation between sensitive and masked points. Disclaimer : MaskMyPy is offered as-is, without warranty of any kind. Geographic masking is a hard problem that requires informed decisions and validation. MaskMyPy provides helpful tools for geographic masking, but does not replace expertise.","title":"Introduction"},{"location":"#installation","text":"pip install maskmypy","title":"Installation"},{"location":"#example","text":"The following snippet applies a 500 meter* donut mask to a GeoDataFrame of sensitive points: >>> from maskmypy import Donut >>> import geopandas as gpd >>> sensitive_points = gpd.read_file('sensitive_points') >>> sensitive_points CID geometry 0 1 POINT (-13703523.337 6313860.932) 1 2 POINT (-13703436.959 6314112.457) 2 3 POINT (-13703679.041 6314040.923) 3 4 POINT (-13703285.553 6313721.356) 4 5 POINT (-13703200.338 6313847.431) >>> masked_points = Donut(sensitive_points, max_distance=500).run() >>> masked_points CID geometry 0 1 POINT (-13703383.941 6313989.161) 1 2 POINT (-13703227.863 6313973.121) 2 3 POINT (-13703313.001 6314172.582) 3 4 POINT (-13703107.232 6313614.978) 4 5 POINT (-13702837.385 6314140.874) We can also calculate the distance that each points was displaced by adding the displacement=True flag to .run() : masked_points = Donut(points).run(displacement=True) masked_points CID geometry _distance 0 1 POINT (-13703383.941 6313989.161) 189.404946 1 2 POINT (-13703227.863 6313973.121) 251.267943 2 3 POINT (-13703313.001 6314172.582) 388.997713 3 4 POINT (-13703107.232 6313614.978) 207.639785 4 5 POINT (-13702837.385 6314140.874) 466.738146 * Note that the max_distance parameter assumes that the supplied distance is in the same unit as the GeoDataFrame. For example, if your GeoDataFrame is projected to a CRS that uses feet, then max_distance=500 will displace points up to 500 feet.","title":"Example"},{"location":"#roadmap","text":"The following features are currently planned: Location Swapping/Verified Neighbor masks Automatic plotting of point displacement The ability to save mask metadata","title":"Roadmap"},{"location":"donut/","text":"Donut Masking \u00b6 Usage: To perform basic donut geomasking on a geodataframe containing sensitive points, with a maximum displacement distance of 500 meters and an minimum displacement distance of 20% of the maximum distance (i.e. 100 meters), the code would look like this: from maskmypy import Donut donutmask = Donut( sensitive=sensitive, # Name of the sensitive geodataframe max_distance=500, # The maximum possible distance that points are displaced ratio=0.2, # The ratio used to define the minimum distance points are displaced distribution='uniform', # The distribution to use when displacing points. Other options include 'gaussian' and 'areal'. 'Areal' distribution means points are more likely to be displaced further within the range. container=container) # Optional, a geodataframe used to ensure that points do not leave a particular area. donutmask.run() masked = donutmask.mask To perform full donut geomasking (i.e. using census data and a target k-anonymity range rather than distance range) with a maximum k-anonymity of 1000 and minimum of 200, and a census geodataframe called population, the code would appear as follows: from maskmypy import Donut_MaxK donutmask = Donut_MaxK( sensitive, # Name of the sensitive geodataframe population=population, # Name of the census geodataframe pop_col='pop', # Name of the column containing the population field max_k_anonymity=1000, # The maximum possible k-anonymity value ratio=0.2, # The ratio used to define the minimum possible k-anonymity value. distribution='uniform', # The distribution to use when displacing points. Other options include 'gaussian' and 'areal'. 'Areal' distribution means points are more likely to be displaced further within the range. container=container) # Optional, a geodataframe used to ensure that points do not leave a particular area. donutmask.run() masked = donutmask.mask","title":"Donut Masking"},{"location":"donut/#donut-masking","text":"Usage: To perform basic donut geomasking on a geodataframe containing sensitive points, with a maximum displacement distance of 500 meters and an minimum displacement distance of 20% of the maximum distance (i.e. 100 meters), the code would look like this: from maskmypy import Donut donutmask = Donut( sensitive=sensitive, # Name of the sensitive geodataframe max_distance=500, # The maximum possible distance that points are displaced ratio=0.2, # The ratio used to define the minimum distance points are displaced distribution='uniform', # The distribution to use when displacing points. Other options include 'gaussian' and 'areal'. 'Areal' distribution means points are more likely to be displaced further within the range. container=container) # Optional, a geodataframe used to ensure that points do not leave a particular area. donutmask.run() masked = donutmask.mask To perform full donut geomasking (i.e. using census data and a target k-anonymity range rather than distance range) with a maximum k-anonymity of 1000 and minimum of 200, and a census geodataframe called population, the code would appear as follows: from maskmypy import Donut_MaxK donutmask = Donut_MaxK( sensitive, # Name of the sensitive geodataframe population=population, # Name of the census geodataframe pop_col='pop', # Name of the column containing the population field max_k_anonymity=1000, # The maximum possible k-anonymity value ratio=0.2, # The ratio used to define the minimum possible k-anonymity value. distribution='uniform', # The distribution to use when displacing points. Other options include 'gaussian' and 'areal'. 'Areal' distribution means points are more likely to be displaced further within the range. container=container) # Optional, a geodataframe used to ensure that points do not leave a particular area. donutmask.run() masked = donutmask.mask","title":"Donut Masking"},{"location":"metrics/","text":"K-Anonymity \u00b6 Maskmypy is able to calculate the k-anonymity of each point after masking. Two methods are available for this: estimates, and exact calculations. Estimates of k-anoynmity are inferred from census data, and assume a homogeneously distributed population within each census polygon. Address-based k-anonymity is more accurate and uses actual home address data to calculate k-anonymity. Estimate K-Anonymity \u00b6 Usage: After the data has been masked, estimating k-anoynmity using census data would look like this and will add a column to the masked geodataframe: mask.k_anonymity_estimate( population=population, # Name of the census geodataframe. Not necessary if you already included this parameter in the original masking steps. pop_col='pop') # Name of the column containing the population field. Not necessary if you already included this parameter in the original masking steps. Calculate K-Anonymity \u00b6 Usage: After the data has been masked, calcualting address-based k-anoynmity would look like this and will add a column to the masked geodataframe: mask.k_anonymity_actual(address='') # Name of the geodataframe including address points. Displacement Distance \u00b6 Usage: To add a column to the masked geodataframe that includes the actual displacement distances (in meters), one can just run: mask.displacement_distance()","title":"Metric Calculation"},{"location":"metrics/#k-anonymity","text":"Maskmypy is able to calculate the k-anonymity of each point after masking. Two methods are available for this: estimates, and exact calculations. Estimates of k-anoynmity are inferred from census data, and assume a homogeneously distributed population within each census polygon. Address-based k-anonymity is more accurate and uses actual home address data to calculate k-anonymity.","title":"K-Anonymity"},{"location":"metrics/#estimate-k-anonymity","text":"Usage: After the data has been masked, estimating k-anoynmity using census data would look like this and will add a column to the masked geodataframe: mask.k_anonymity_estimate( population=population, # Name of the census geodataframe. Not necessary if you already included this parameter in the original masking steps. pop_col='pop') # Name of the column containing the population field. Not necessary if you already included this parameter in the original masking steps.","title":"Estimate K-Anonymity"},{"location":"metrics/#calculate-k-anonymity","text":"Usage: After the data has been masked, calcualting address-based k-anoynmity would look like this and will add a column to the masked geodataframe: mask.k_anonymity_actual(address='') # Name of the geodataframe including address points.","title":"Calculate K-Anonymity"},{"location":"metrics/#displacement-distance","text":"Usage: To add a column to the masked geodataframe that includes the actual displacement distances (in meters), one can just run: mask.displacement_distance()","title":"Displacement Distance"},{"location":"street/","text":"Street Masking \u00b6 Street masking automatically downloads OpenStreetMap road network data and uses it to geographically mask your sensitive points. It works by first downloading the road network data, snapping each sensitive point to the nearest node on the network (an intersection or dead end), and then calculating the average network-distance between that node and a pool of the closest x number of nodes (e.g. the closest 20 nodes on the network, known as the search depth). This average distance is the target displacement distance. Finally, it selects a node from the pool whose network-distance from the starting node is closest to the target displacement distance. Usage: To street mask a geodataframe containing sensitive points with a search-depth value of 20, the code would be as follows: from maskmypy import Street streetmask = Street( sensitive, # Name of the sensitive geodataframe depth=20, # The search depth value used to calculate displacement distances. padding=2000, # Used to download road network data surrounding the study area. Needs to be sufficiently large to reduce edge effects. Increasing reduces edge effects, but uses more memory. max_length=500) # Optional, but recommended that you read below for full explanation of what this does. streetmask.run() # Single threaded by default. Add `parallel=True` as parameter to run on all CPU cores, drastically increasing performance. masked = streetmask.mask About max_length : when snapping points to the street network, the algorithm checks to make sure that the nearest node is actually connected to the network and has neighbors that are no more than max_length away (in meters). If it does not, then the next closest viable node is selected, checked, and so on. This acts as a sanity check to prevent extremely large masking distances. Feel free to change this to whatever you feel is appropriate.","title":"Street Masking"},{"location":"street/#street-masking","text":"Street masking automatically downloads OpenStreetMap road network data and uses it to geographically mask your sensitive points. It works by first downloading the road network data, snapping each sensitive point to the nearest node on the network (an intersection or dead end), and then calculating the average network-distance between that node and a pool of the closest x number of nodes (e.g. the closest 20 nodes on the network, known as the search depth). This average distance is the target displacement distance. Finally, it selects a node from the pool whose network-distance from the starting node is closest to the target displacement distance. Usage: To street mask a geodataframe containing sensitive points with a search-depth value of 20, the code would be as follows: from maskmypy import Street streetmask = Street( sensitive, # Name of the sensitive geodataframe depth=20, # The search depth value used to calculate displacement distances. padding=2000, # Used to download road network data surrounding the study area. Needs to be sufficiently large to reduce edge effects. Increasing reduces edge effects, but uses more memory. max_length=500) # Optional, but recommended that you read below for full explanation of what this does. streetmask.run() # Single threaded by default. Add `parallel=True` as parameter to run on all CPU cores, drastically increasing performance. masked = streetmask.mask About max_length : when snapping points to the street network, the algorithm checks to make sure that the nearest node is actually connected to the network and has neighbors that are no more than max_length away (in meters). If it does not, then the next closest viable node is selected, checked, and so on. This acts as a sanity check to prevent extremely large masking distances. Feel free to change this to whatever you feel is appropriate.","title":"Street Masking"},{"location":"tests/","text":"Testing \u00b6 This is just a random sample","title":"Testing"},{"location":"tests/#testing","text":"This is just a random sample","title":"Testing"}]}