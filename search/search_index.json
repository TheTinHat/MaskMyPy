{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MaskMyPy \u00b6 Key Features \u00b6 Python tools for anonymizing geographic point data held in GeoDataFrames. Includes three approaches towards donut masking. Includes a new OpenStreetMap-based approach called street masking. Tools for assessing displacement distance & spatial k-anonymity. A command line interface (CLI) for quick masking jobs. Introduction \u00b6 MaskMyPy is a Python package that performs geographic masking on GeoDataFrames . In other words, MaskMyPy provides spatial anonymization functions for point data. It currently offers two main methods: donut masking and street masking . MaskMyPy also includes tools to help optimize and validate masking parameters. These include k-anonymity estimation using population data, k-anonymity calculation using address data, and displacement distance calculation between sensitive and masked points. Disclaimer : MaskMyPy is offered as-is, without warranty of any kind. Geographic masking is a hard problem that requires informed decisions and validation. MaskMyPy provides helpful tools for geographic masking, but does not replace expertise. Installation \u00b6 pip install maskmypy Quick Usage \u00b6 Masking/Anonymization \u00b6 The following snippet applies a 500 meter donut mask to a GeoDataFrame of sensitive (e.g. secret) points: >>> from maskmypy import Donut >>> import geopandas as gpd >>> secret = gpd . read_file ( 'secret_points' ) >>> secret . head () CID geometry 0 1 POINT ( - 13703523.337 6313860.932 ) 1 2 POINT ( - 13703436.959 6314112.457 ) 2 3 POINT ( - 13703679.041 6314040.923 ) 3 4 POINT ( - 13703285.553 6313721.356 ) 4 5 POINT ( - 13703200.338 6313847.431 ) >>> masked_points = Donut ( secret , max_distance = 500 ) . run () >>> masked_points . head () CID geometry 0 1 POINT ( - 13703383.941 6313989.161 ) 1 2 POINT ( - 13703227.863 6313973.121 ) 2 3 POINT ( - 13703313.001 6314172.582 ) 3 4 POINT ( - 13703107.232 6313614.978 ) 4 5 POINT ( - 13702837.385 6314140.874 ) Unless specified, MaskMyPy uses the same units of distance as the CRS of the input secret points. If our secret points instead used a CRS that is in feet, then our mask would have had a maximum distance of 500 feet. Evaluation \u00b6 We can also add some parameters to the .run() method to help us better evaluate our masking results. For instance, we can visually inspect the masking process by creating a rudimentary map of displacement distances like so: >>> masked_points = Donut ( secret , max_distance = 500 ) . run ( map_displacement = True ) To more rigorously evaluate our results, we could add a context layer of address points and use it to calculate the k-anonymity of each masked point: >>> address_points = gpd . read_file ( 'addresses.shp' ) >>> masked_points = Donut ( secret , max_distance = 500 , address = address_points ) . run ( calculate_k = True ) >>> masked_points . head () CID geometry k_calc 0 1 POINT ( - 13703383.941 6313989.161 ) 19 1 2 POINT ( - 13703227.863 6313973.121 ) 15 2 3 POINT ( - 13703313.001 6314172.582 ) 43 3 4 POINT ( - 13703107.232 6313614.978 ) 23 4 5 POINT ( - 13702837.385 6314140.874 ) 51 See here to find other useful .run() parameters. Command Line Interface (CLI) \u00b6 MaskMyPy also has a limited command line interface for quick jobs on shapefiles. The CLI contains commands for both Donut and Street masking classes (it does not support Donut_K or Donut_Multiply). Here's the command to Street mask a input shapefile of points and save it as masked_points.shp : maskmypy street --max-depth 25 secret_points.shp masked_points.shp To find out more, just run maskmypy --help . Roadmap \u00b6 The following features are currently planned: Location Swapping/Verified Neighbor masks Mask metadata export Data suppression tools Contribute \u00b6 Any and all efforts to contribute are welcome, whether they include actual code or just feedback. In particular, I could use some help with: Architecture. Don't hesitate to point out things that look downright weird. Tests. A range of unit tests are already included for Donut masking, but the Street mask tests are currently a bit thin comparatively. Documentation. Even just pointing out areas where you feel could use more documentation would be most helpful. Developers, please keep the following in mind: You can install the necessary development tools by cloning the repo and running pip install -e .[develop] . MaskMyPy uses black with a line length of 99 to format the codebase. Please run black -l 99 before submitting any pull requests. Run pytest from the project root before submitting any code changes to ensure that your changes do not break anything. Please include any appropriate unit tests with any feature contributions.","title":"Home"},{"location":"#maskmypy","text":"","title":"MaskMyPy"},{"location":"#key-features","text":"Python tools for anonymizing geographic point data held in GeoDataFrames. Includes three approaches towards donut masking. Includes a new OpenStreetMap-based approach called street masking. Tools for assessing displacement distance & spatial k-anonymity. A command line interface (CLI) for quick masking jobs.","title":"Key Features"},{"location":"#introduction","text":"MaskMyPy is a Python package that performs geographic masking on GeoDataFrames . In other words, MaskMyPy provides spatial anonymization functions for point data. It currently offers two main methods: donut masking and street masking . MaskMyPy also includes tools to help optimize and validate masking parameters. These include k-anonymity estimation using population data, k-anonymity calculation using address data, and displacement distance calculation between sensitive and masked points. Disclaimer : MaskMyPy is offered as-is, without warranty of any kind. Geographic masking is a hard problem that requires informed decisions and validation. MaskMyPy provides helpful tools for geographic masking, but does not replace expertise.","title":"Introduction"},{"location":"#installation","text":"pip install maskmypy","title":"Installation"},{"location":"#quick-usage","text":"","title":"Quick Usage"},{"location":"#maskinganonymization","text":"The following snippet applies a 500 meter donut mask to a GeoDataFrame of sensitive (e.g. secret) points: >>> from maskmypy import Donut >>> import geopandas as gpd >>> secret = gpd . read_file ( 'secret_points' ) >>> secret . head () CID geometry 0 1 POINT ( - 13703523.337 6313860.932 ) 1 2 POINT ( - 13703436.959 6314112.457 ) 2 3 POINT ( - 13703679.041 6314040.923 ) 3 4 POINT ( - 13703285.553 6313721.356 ) 4 5 POINT ( - 13703200.338 6313847.431 ) >>> masked_points = Donut ( secret , max_distance = 500 ) . run () >>> masked_points . head () CID geometry 0 1 POINT ( - 13703383.941 6313989.161 ) 1 2 POINT ( - 13703227.863 6313973.121 ) 2 3 POINT ( - 13703313.001 6314172.582 ) 3 4 POINT ( - 13703107.232 6313614.978 ) 4 5 POINT ( - 13702837.385 6314140.874 ) Unless specified, MaskMyPy uses the same units of distance as the CRS of the input secret points. If our secret points instead used a CRS that is in feet, then our mask would have had a maximum distance of 500 feet.","title":"Masking/Anonymization"},{"location":"#evaluation","text":"We can also add some parameters to the .run() method to help us better evaluate our masking results. For instance, we can visually inspect the masking process by creating a rudimentary map of displacement distances like so: >>> masked_points = Donut ( secret , max_distance = 500 ) . run ( map_displacement = True ) To more rigorously evaluate our results, we could add a context layer of address points and use it to calculate the k-anonymity of each masked point: >>> address_points = gpd . read_file ( 'addresses.shp' ) >>> masked_points = Donut ( secret , max_distance = 500 , address = address_points ) . run ( calculate_k = True ) >>> masked_points . head () CID geometry k_calc 0 1 POINT ( - 13703383.941 6313989.161 ) 19 1 2 POINT ( - 13703227.863 6313973.121 ) 15 2 3 POINT ( - 13703313.001 6314172.582 ) 43 3 4 POINT ( - 13703107.232 6313614.978 ) 23 4 5 POINT ( - 13702837.385 6314140.874 ) 51 See here to find other useful .run() parameters.","title":"Evaluation"},{"location":"#command-line-interface-cli","text":"MaskMyPy also has a limited command line interface for quick jobs on shapefiles. The CLI contains commands for both Donut and Street masking classes (it does not support Donut_K or Donut_Multiply). Here's the command to Street mask a input shapefile of points and save it as masked_points.shp : maskmypy street --max-depth 25 secret_points.shp masked_points.shp To find out more, just run maskmypy --help .","title":"Command Line Interface (CLI)"},{"location":"#roadmap","text":"The following features are currently planned: Location Swapping/Verified Neighbor masks Mask metadata export Data suppression tools","title":"Roadmap"},{"location":"#contribute","text":"Any and all efforts to contribute are welcome, whether they include actual code or just feedback. In particular, I could use some help with: Architecture. Don't hesitate to point out things that look downright weird. Tests. A range of unit tests are already included for Donut masking, but the Street mask tests are currently a bit thin comparatively. Documentation. Even just pointing out areas where you feel could use more documentation would be most helpful. Developers, please keep the following in mind: You can install the necessary development tools by cloning the repo and running pip install -e .[develop] . MaskMyPy uses black with a line length of 99 to format the codebase. Please run black -l 99 before submitting any pull requests. Run pytest from the project root before submitting any code changes to ensure that your changes do not break anything. Please include any appropriate unit tests with any feature contributions.","title":"Contribute"},{"location":"api_reference/","text":"Masks \u00b6 Every available mask inherits from the maskmypy.mask.Mask class. To reduce a huge amount of duplicated documentation, only new parameters are described in child classes. Refer to the parent class for a full list of parameters. maskmypy . mask . Mask ( secret , population = None , pop_col = 'pop' , container = None , address = None , padding = None , max_tries = 1000 , seed = None ) \u00b6 A base class that all masks inherit from. Do not use this class for masking. Parameters: Name Type Description Default secret GeoDataFrame Secret layer of points that require anonymization. All other GeoDataFrame inputs must match the CRS of the secret point layer. required padding int , float , optional Context layers (e.g. population, address, container, street network) are automatically cropped to the extent of the secret layer, plus some amount of padding to reduce edge effects. By default, padding is set to one fifth the x or y extent, whichever is larger. This parameter allows you to instead specify an exact amount of padding to be added. Recommended if the extent of the secret layer is either very small or very large. Units should match that of the secret layer's CRS. None max_tries int , optional The maximum number of times that MaskMyPy should re-mask a point until it is contained within the corresponding polygon (see container parameter). 1000 seed int , optional Used to seed the random number generator so that masks are reproducible. In other words, given a certain seed, MaskMyPy will always mask data the exact same way. If left unspecified, a seed is randomly selected using SystemRandom None population GeoDataFrame , optional A polygon layer with a column describing population count. None pop_col str , optional The name of the population count column in the population polygon layer. 'pop' container GeoDataFrame , optional A layer containing polygons within which intersecting secret points should remain after masking. This works by masking a point, checking if it intersects the same polygon prior to masking, and retrying until it does. The number of attempts is controlled by the max_tries parameter. Useful for preserving statistical values, such as from census tracts, or to ensure that points are not displaced into impossible locations, such as the ocean. None address GeoDataFrame , optional A layer containing address points. None run ( displacement = False , estimate_k = False , calculate_k = False , map_displacement = False ) \u00b6 Run the masking procedure to anonymize secret points. Parameters: Name Type Description Default displacement bool , optional If True , add a distance column containing the displacement distance. False estimate_k bool , optional If True , estimate the k-anonymity of each anonymized point based on surrounding population density. Requires a population layer to be loaded into the masking object. False calculate_k bool , optional If True , calculate the k-anonymity of each anonymized point based on nearby address points. Requires an address layer to be loaded into the masking class. False map_displacement bool , optional If True , output a file called displacement_map.png that visualizes displacement distance between secret and masked points. False Returns: Type Description GeoDataFrame A GeoDataFrame of anonymized points. maskmypy . Donut ( * args , min_distance = 50 , max_distance = 500 , distribution = 'uniform' , ** kwargs ) \u00b6 Bases: Mask Constructs a donut masking class that (when run) anonymizes points by randomly displacing them between a minimum and maximum distance. Parameters: Name Type Description Default min_distance int , float The minimum distance that points should be displaced. 50 max_distance int , float The maximum distance that points should be displaced. 500 distribution str , optional The distribution used to determine masking distances. The default uniform provides a flat distribution where any value between the minimum and maximum distance is equally likely to be selected. The areal distribution is more likely to select distances that are further away. The gaussian distribution uses a normal distribution, where values towards the middle of the range are most likely to be selected. Note that gaussian distribution has a small chance of selecting values beyond the defined minimum and maximum. 'uniform' maskmypy . Donut_Multiply ( * args , population_multiplier = 5 , ** kwargs ) \u00b6 Bases: Donut Constructs a masking class that (when run) anonymizes points by randomly displacing them according to a minimum and maximum distance, but with an additional multiplier to help take population density into account. Points in the most population-dense areas will have their minimum and maximum masking distances multiplied by 1. This multiplier will increase linearly as population density decreases, with points in the least population-dense areas having their minimum and maximum masking distances multiplied by the full population_mulitplier value. Requires a population layer. Parameters: Name Type Description Default population_multiplier int , float The maximum possible multiplier used to extend masking distances according to population density. 5 maskmypy . Donut_K ( * args , min_k , max_k , ** kwargs ) \u00b6 Bases: Donut Constructs a masking class that (when run) anonymizes points by randomly displacing them according to a desired k-anonymity range. Note that the k-anonymity values only reflect the population density at the point location itself, and do not take into account any surrounding area. This is in contrast to the estimate_k tool, which will actually disaggregate nearby population polygons to construct a more accurate estimate of k-anonymity. Requires a population layer. Parameters: Name Type Description Default min_k int The minimum desired k-anonymity for each point. Used instead of min_distance . Please read description above to learn the limitations of this calculation. required max_k int The maximum desired k-anonymity for each point. Used instead of max_distance . Please read description above to learn the limitations of this calculation. required maskmypy . Street ( * args , min_depth = 18 , max_depth = 20 , max_length = 500 , ** kwargs ) \u00b6 Bases: Mask Constructs a street masking class that (when run) anonymizes points by randomly displacing them based on the surrounding street network using OpenStreetMap. Does not support containment. Parameters: Name Type Description Default min_depth int , optional The minimum number of nodes to traverse along the street network. Default: 18 18 max_depth int , optional The maximum number of nodes to traverse along the street network. Default: 20 20 max_length int , float , optional Sets a limit for street length, such that any street segments longer than this value will be ignored. Useful for ignoring very long streets that would skew the results, such as highways. 500 Tools \u00b6 MaskMyPy offers several tools for evaluating geographic masks, even if they were not performed by MaskMyPy. maskmypy . tools . displacement ( secret , mask , colname = '_distance' ) \u00b6 Calculates the displacement distance between secret and masked points. Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required colname str , optional Name for the output displacement distance column, by default \"_distance\" '_distance' Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing displacement distances maskmypy . tools . estimate_k ( secret , mask , population , pop_col = 'pop' ) \u00b6 Estimate the k-anonymity of each anonymized point based on surrounding population density. Typically less accurate the calculate_k . Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required population GeoDataFrame A polygon layer with a column describing population count. required pop_col str , optional The name of the population count column in the population polygon layer. 'pop' Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing k-anonymity. maskmypy . tools . calculate_k ( secret , mask , address ) \u00b6 Calculate the k-anonymity of each anonymized point based on surrounding address points. Typically more accurate the estimate_k . Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required address GeoDataFrame , optional A layer containing address points. required Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing k-anonymity. maskmypy . tools . map_displacement ( secret , mask , filename = None , address = None ) \u00b6 Creates a map visualizing the displacement of each point between its original and masked location. Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required filename str , optional If specified, saves the output map to a file. None address GeoDataFrame , optional A layer containing address points. None Returns: Type Description matplotlib . pyplot . plt A plot depicting secret and masked points connected by lines.","title":"API Reference"},{"location":"api_reference/#masks","text":"Every available mask inherits from the maskmypy.mask.Mask class. To reduce a huge amount of duplicated documentation, only new parameters are described in child classes. Refer to the parent class for a full list of parameters.","title":"Masks"},{"location":"api_reference/#maskmypy.mask.Mask","text":"A base class that all masks inherit from. Do not use this class for masking. Parameters: Name Type Description Default secret GeoDataFrame Secret layer of points that require anonymization. All other GeoDataFrame inputs must match the CRS of the secret point layer. required padding int , float , optional Context layers (e.g. population, address, container, street network) are automatically cropped to the extent of the secret layer, plus some amount of padding to reduce edge effects. By default, padding is set to one fifth the x or y extent, whichever is larger. This parameter allows you to instead specify an exact amount of padding to be added. Recommended if the extent of the secret layer is either very small or very large. Units should match that of the secret layer's CRS. None max_tries int , optional The maximum number of times that MaskMyPy should re-mask a point until it is contained within the corresponding polygon (see container parameter). 1000 seed int , optional Used to seed the random number generator so that masks are reproducible. In other words, given a certain seed, MaskMyPy will always mask data the exact same way. If left unspecified, a seed is randomly selected using SystemRandom None population GeoDataFrame , optional A polygon layer with a column describing population count. None pop_col str , optional The name of the population count column in the population polygon layer. 'pop' container GeoDataFrame , optional A layer containing polygons within which intersecting secret points should remain after masking. This works by masking a point, checking if it intersects the same polygon prior to masking, and retrying until it does. The number of attempts is controlled by the max_tries parameter. Useful for preserving statistical values, such as from census tracts, or to ensure that points are not displaced into impossible locations, such as the ocean. None address GeoDataFrame , optional A layer containing address points. None","title":"Mask"},{"location":"api_reference/#maskmypy.mask.Mask.run","text":"Run the masking procedure to anonymize secret points. Parameters: Name Type Description Default displacement bool , optional If True , add a distance column containing the displacement distance. False estimate_k bool , optional If True , estimate the k-anonymity of each anonymized point based on surrounding population density. Requires a population layer to be loaded into the masking object. False calculate_k bool , optional If True , calculate the k-anonymity of each anonymized point based on nearby address points. Requires an address layer to be loaded into the masking class. False map_displacement bool , optional If True , output a file called displacement_map.png that visualizes displacement distance between secret and masked points. False Returns: Type Description GeoDataFrame A GeoDataFrame of anonymized points.","title":"run()"},{"location":"api_reference/#maskmypy.Donut","text":"Bases: Mask Constructs a donut masking class that (when run) anonymizes points by randomly displacing them between a minimum and maximum distance. Parameters: Name Type Description Default min_distance int , float The minimum distance that points should be displaced. 50 max_distance int , float The maximum distance that points should be displaced. 500 distribution str , optional The distribution used to determine masking distances. The default uniform provides a flat distribution where any value between the minimum and maximum distance is equally likely to be selected. The areal distribution is more likely to select distances that are further away. The gaussian distribution uses a normal distribution, where values towards the middle of the range are most likely to be selected. Note that gaussian distribution has a small chance of selecting values beyond the defined minimum and maximum. 'uniform'","title":"Donut"},{"location":"api_reference/#maskmypy.Donut_Multiply","text":"Bases: Donut Constructs a masking class that (when run) anonymizes points by randomly displacing them according to a minimum and maximum distance, but with an additional multiplier to help take population density into account. Points in the most population-dense areas will have their minimum and maximum masking distances multiplied by 1. This multiplier will increase linearly as population density decreases, with points in the least population-dense areas having their minimum and maximum masking distances multiplied by the full population_mulitplier value. Requires a population layer. Parameters: Name Type Description Default population_multiplier int , float The maximum possible multiplier used to extend masking distances according to population density. 5","title":"Donut_Multiply"},{"location":"api_reference/#maskmypy.Donut_K","text":"Bases: Donut Constructs a masking class that (when run) anonymizes points by randomly displacing them according to a desired k-anonymity range. Note that the k-anonymity values only reflect the population density at the point location itself, and do not take into account any surrounding area. This is in contrast to the estimate_k tool, which will actually disaggregate nearby population polygons to construct a more accurate estimate of k-anonymity. Requires a population layer. Parameters: Name Type Description Default min_k int The minimum desired k-anonymity for each point. Used instead of min_distance . Please read description above to learn the limitations of this calculation. required max_k int The maximum desired k-anonymity for each point. Used instead of max_distance . Please read description above to learn the limitations of this calculation. required","title":"Donut_K"},{"location":"api_reference/#maskmypy.Street","text":"Bases: Mask Constructs a street masking class that (when run) anonymizes points by randomly displacing them based on the surrounding street network using OpenStreetMap. Does not support containment. Parameters: Name Type Description Default min_depth int , optional The minimum number of nodes to traverse along the street network. Default: 18 18 max_depth int , optional The maximum number of nodes to traverse along the street network. Default: 20 20 max_length int , float , optional Sets a limit for street length, such that any street segments longer than this value will be ignored. Useful for ignoring very long streets that would skew the results, such as highways. 500","title":"Street"},{"location":"api_reference/#tools","text":"MaskMyPy offers several tools for evaluating geographic masks, even if they were not performed by MaskMyPy.","title":"Tools"},{"location":"api_reference/#maskmypy.tools.displacement","text":"Calculates the displacement distance between secret and masked points. Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required colname str , optional Name for the output displacement distance column, by default \"_distance\" '_distance' Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing displacement distances","title":"displacement()"},{"location":"api_reference/#maskmypy.tools.estimate_k","text":"Estimate the k-anonymity of each anonymized point based on surrounding population density. Typically less accurate the calculate_k . Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required population GeoDataFrame A polygon layer with a column describing population count. required pop_col str , optional The name of the population count column in the population polygon layer. 'pop' Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing k-anonymity.","title":"estimate_k()"},{"location":"api_reference/#maskmypy.tools.calculate_k","text":"Calculate the k-anonymity of each anonymized point based on surrounding address points. Typically more accurate the estimate_k . Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required address GeoDataFrame , optional A layer containing address points. required Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing k-anonymity.","title":"calculate_k()"},{"location":"api_reference/#maskmypy.tools.map_displacement","text":"Creates a map visualizing the displacement of each point between its original and masked location. Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required filename str , optional If specified, saves the output map to a file. None address GeoDataFrame , optional A layer containing address points. None Returns: Type Description matplotlib . pyplot . plt A plot depicting secret and masked points connected by lines.","title":"map_displacement()"},{"location":"donut/","text":"What is Donut Masking \u00b6 At its most basic, donut masking is an anonymization technique that works by randomly displacing each point between a specified minimum and maximum distance, as pictured below. This makes it a stronger form of random perturbation, which uses no minimum distance and thus runs the risk of insufficiently anonymizing points. MaskMyPy offers donut masking using the Donut masking class. Donut masking can be further strengthened by adding some form of population data into the mix. As one can imagine, a point in a downtown core won't need to be displaced nearly as far as a point in the surrounding suburbs to achieve similar levels of anonymity. As such, MaskMyPy offers two additional donut masking classes to help take population density into account: Donut_Multiply and Donut_K . Both masks require a context layer of polygons containing population counts (e.g. census tracts), but leverage this information in different ways. Donut_Multiply works by multiplying masking distances based on the relative population density of the polygon it falls within. This means that points in the most dense areas of a given dataset will have their masking distance multiplied by 1, whereas points within the least dense areas of that same dataset will have their masking distance multiplied by 5. Of course, this multiplier is configurable, 5 is just the default. Donut_K works a bit differently. Rather than taking a range of masking distances as input, Donut_K takes a desired level of anonymity as input, then figures out the masking distances that are required to achieve that. This level of anonymity is known as k-anonymity , and essentially refers to the size of crowd that the point (theoretically) blends into. There is a caveat, however: MaskMyPy is only able to factor in the population density of the immediate polygon that the point falls within. This means that if there's neighboring polygons with significantly different population densities, they will not be accounted for. So as always, be careful, understand your data, and validate that the masked data is sufficiently protected. Usage \u00b6 To perform basic donut geomasking on a geodataframe containing secret points, with a maximum displacement distance of 500 meters and an minimum displacement distance of 20% of the maximum distance (i.e. 100 meters), the code would look like this: from maskmypy import Donut donutmask = Donut ( sensitive = sensitive , # Name of the sensitive geodataframe max_distance = 500 , # The maximum possible distance that points are displaced ratio = 0.2 , # The ratio used to define the minimum distance points are displaced distribution = 'uniform' , # The distribution to use when displacing points. Other options include 'gaussian' and 'areal'. 'Areal' distribution means points are more likely to be displaced further within the range. container = container ) # Optional, a geodataframe used to ensure that points do not leave a particular area. donutmask . run () masked = donutmask . mask To perform full donut geomasking (i.e. using census data and a target k-anonymity range rather than distance range) with a maximum k-anonymity of 1000 and minimum of 200, and a census geodataframe called population, the code would appear as follows: from maskmypy import Donut_K donutmask = Donut_K ( sensitive , # Name of the sensitive geodataframe population = population , # Name of the census geodataframe pop_col = 'pop' , # Name of the column containing the population field max_k = 1000 , # The maximum possible k-anonymity value ratio = 0.2 , # The ratio used to define the minimum possible k-anonymity value. distribution = 'uniform' , # The distribution to use when displacing points. Other options include 'gaussian' and 'areal'. 'Areal' distribution means points are more likely to be displaced further within the range. container = container ) # Optional, a geodataframe used to ensure that points do not leave a particular area. donutmask . run () masked = donutmask . mask","title":"Donut Masking"},{"location":"donut/#what-is-donut-masking","text":"At its most basic, donut masking is an anonymization technique that works by randomly displacing each point between a specified minimum and maximum distance, as pictured below. This makes it a stronger form of random perturbation, which uses no minimum distance and thus runs the risk of insufficiently anonymizing points. MaskMyPy offers donut masking using the Donut masking class. Donut masking can be further strengthened by adding some form of population data into the mix. As one can imagine, a point in a downtown core won't need to be displaced nearly as far as a point in the surrounding suburbs to achieve similar levels of anonymity. As such, MaskMyPy offers two additional donut masking classes to help take population density into account: Donut_Multiply and Donut_K . Both masks require a context layer of polygons containing population counts (e.g. census tracts), but leverage this information in different ways. Donut_Multiply works by multiplying masking distances based on the relative population density of the polygon it falls within. This means that points in the most dense areas of a given dataset will have their masking distance multiplied by 1, whereas points within the least dense areas of that same dataset will have their masking distance multiplied by 5. Of course, this multiplier is configurable, 5 is just the default. Donut_K works a bit differently. Rather than taking a range of masking distances as input, Donut_K takes a desired level of anonymity as input, then figures out the masking distances that are required to achieve that. This level of anonymity is known as k-anonymity , and essentially refers to the size of crowd that the point (theoretically) blends into. There is a caveat, however: MaskMyPy is only able to factor in the population density of the immediate polygon that the point falls within. This means that if there's neighboring polygons with significantly different population densities, they will not be accounted for. So as always, be careful, understand your data, and validate that the masked data is sufficiently protected.","title":"What is Donut Masking"},{"location":"donut/#usage","text":"To perform basic donut geomasking on a geodataframe containing secret points, with a maximum displacement distance of 500 meters and an minimum displacement distance of 20% of the maximum distance (i.e. 100 meters), the code would look like this: from maskmypy import Donut donutmask = Donut ( sensitive = sensitive , # Name of the sensitive geodataframe max_distance = 500 , # The maximum possible distance that points are displaced ratio = 0.2 , # The ratio used to define the minimum distance points are displaced distribution = 'uniform' , # The distribution to use when displacing points. Other options include 'gaussian' and 'areal'. 'Areal' distribution means points are more likely to be displaced further within the range. container = container ) # Optional, a geodataframe used to ensure that points do not leave a particular area. donutmask . run () masked = donutmask . mask To perform full donut geomasking (i.e. using census data and a target k-anonymity range rather than distance range) with a maximum k-anonymity of 1000 and minimum of 200, and a census geodataframe called population, the code would appear as follows: from maskmypy import Donut_K donutmask = Donut_K ( sensitive , # Name of the sensitive geodataframe population = population , # Name of the census geodataframe pop_col = 'pop' , # Name of the column containing the population field max_k = 1000 , # The maximum possible k-anonymity value ratio = 0.2 , # The ratio used to define the minimum possible k-anonymity value. distribution = 'uniform' , # The distribution to use when displacing points. Other options include 'gaussian' and 'areal'. 'Areal' distribution means points are more likely to be displaced further within the range. container = container ) # Optional, a geodataframe used to ensure that points do not leave a particular area. donutmask . run () masked = donutmask . mask","title":"Usage"},{"location":"street/","text":"What is Street Masking \u00b6 Street masking automatically downloads OpenStreetMap road network data and uses it to geographically mask your sensitive points. It works by first downloading the road network data, snapping each sensitive point to the nearest node on the network (an intersection or dead end), and then calculating the average network-distance between that node and a pool of the closest x number of nodes (e.g. the closest 20 nodes on the network, known as the search depth). This average distance is the target displacement distance. Finally, it selects a node from the pool whose network-distance from the starting node is closest to the target displacement distance. You can read more about street masking in this peer reviewed article . (Note: this diagram is slightly dated as street masking now includes a randomization element. Specifically, depth values are now provided as a range within which a value is selected at random for each point. This makes it more difficult for an attacker to re-identify any given masked point.) Usage \u00b6 To street mask a GeoDataFrame containing sensitive points with a search-depth value of 20, the code would be as follows: from maskmypy import Street streetmask = Street ( sensitive , # Name of the sensitive GeoDataFrame depth = 20 , # The search depth value used to calculate displacement distances. padding = 2000 , # Used to download road network data surrounding the study area. Needs to be sufficiently large to reduce edge effects. Increasing reduces edge effects, but uses more memory. max_length = 500 ) # Optional, but recommended that you read below for full explanation of what this does. streetmask . run () # Single threaded by default. Add `parallel=True` as parameter to run on all CPU cores, drastically increasing performance. masked = streetmask . mask About max_length : when snapping points to the street network, the algorithm checks to make sure that the nearest node is actually connected to the network and has neighbors that are no more than max_length away (in meters). If it does not, then the next closest viable node is selected, checked, and so on. This acts as a sanity check to prevent extremely large masking distances. Feel free to change this to whatever you feel is appropriate.","title":"Street Masking"},{"location":"street/#what-is-street-masking","text":"Street masking automatically downloads OpenStreetMap road network data and uses it to geographically mask your sensitive points. It works by first downloading the road network data, snapping each sensitive point to the nearest node on the network (an intersection or dead end), and then calculating the average network-distance between that node and a pool of the closest x number of nodes (e.g. the closest 20 nodes on the network, known as the search depth). This average distance is the target displacement distance. Finally, it selects a node from the pool whose network-distance from the starting node is closest to the target displacement distance. You can read more about street masking in this peer reviewed article . (Note: this diagram is slightly dated as street masking now includes a randomization element. Specifically, depth values are now provided as a range within which a value is selected at random for each point. This makes it more difficult for an attacker to re-identify any given masked point.)","title":"What is Street Masking"},{"location":"street/#usage","text":"To street mask a GeoDataFrame containing sensitive points with a search-depth value of 20, the code would be as follows: from maskmypy import Street streetmask = Street ( sensitive , # Name of the sensitive GeoDataFrame depth = 20 , # The search depth value used to calculate displacement distances. padding = 2000 , # Used to download road network data surrounding the study area. Needs to be sufficiently large to reduce edge effects. Increasing reduces edge effects, but uses more memory. max_length = 500 ) # Optional, but recommended that you read below for full explanation of what this does. streetmask . run () # Single threaded by default. Add `parallel=True` as parameter to run on all CPU cores, drastically increasing performance. masked = streetmask . mask About max_length : when snapping points to the street network, the algorithm checks to make sure that the nearest node is actually connected to the network and has neighbors that are no more than max_length away (in meters). If it does not, then the next closest viable node is selected, checked, and so on. This acts as a sanity check to prevent extremely large masking distances. Feel free to change this to whatever you feel is appropriate.","title":"Usage"},{"location":"tools/","text":"K-Anonymity \u00b6 Maskmypy is able to calculate the k-anonymity of each point after masking. Two methods are available for this: estimates, and exact calculations. Estimates of k-anoynmity are inferred from census data, and assume a homogeneously distributed population within each census polygon. Address-based k-anonymity is more accurate and uses actual home address data to calculate k-anonymity. Estimate K-Anonymity \u00b6 Usage: After the data has been masked, estimating k-anoynmity using census data would look like this and will add a column to the masked geodataframe: mask . estimate_k ( population = population , # Name of the census geodataframe. Not necessary if you already included this parameter in the original masking steps. pop_col = 'pop' ) # Name of the column containing the population field. Not necessary if you already included this parameter in the original masking steps. Calculate K-Anonymity \u00b6 Usage: After the data has been masked, calcualting address-based k-anoynmity would look like this and will add a column to the masked geodataframe: mask . calculate_k ( address = '' ) # Name of the geodataframe including address points. Displacement Distance \u00b6 Usage: To add a column to the masked geodataframe that includes the actual displacement distances (in meters), one can just run: mask . displacement () tools.displacement() \u00b6 maskmypy . tools . displacement ( secret , mask , colname = '_distance' ) \u00b6 Calculates the displacement distance between secret and masked points. Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required colname str , optional Name for the output displacement distance column, by default \"_distance\" '_distance' Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing displacement distances","title":"Tools"},{"location":"tools/#k-anonymity","text":"Maskmypy is able to calculate the k-anonymity of each point after masking. Two methods are available for this: estimates, and exact calculations. Estimates of k-anoynmity are inferred from census data, and assume a homogeneously distributed population within each census polygon. Address-based k-anonymity is more accurate and uses actual home address data to calculate k-anonymity.","title":"K-Anonymity"},{"location":"tools/#estimate-k-anonymity","text":"Usage: After the data has been masked, estimating k-anoynmity using census data would look like this and will add a column to the masked geodataframe: mask . estimate_k ( population = population , # Name of the census geodataframe. Not necessary if you already included this parameter in the original masking steps. pop_col = 'pop' ) # Name of the column containing the population field. Not necessary if you already included this parameter in the original masking steps.","title":"Estimate K-Anonymity"},{"location":"tools/#calculate-k-anonymity","text":"Usage: After the data has been masked, calcualting address-based k-anoynmity would look like this and will add a column to the masked geodataframe: mask . calculate_k ( address = '' ) # Name of the geodataframe including address points.","title":"Calculate K-Anonymity"},{"location":"tools/#displacement-distance","text":"Usage: To add a column to the masked geodataframe that includes the actual displacement distances (in meters), one can just run: mask . displacement ()","title":"Displacement Distance"},{"location":"tools/#toolsdisplacement","text":"","title":"tools.displacement()"},{"location":"tools/#maskmypy.tools.displacement","text":"Calculates the displacement distance between secret and masked points. Parameters: Name Type Description Default secret GeoDataFrame Secret points prior to masking. required mask GeoDataFrame Points after masking required colname str , optional Name for the output displacement distance column, by default \"_distance\" '_distance' Returns: Type Description GeoDataFrame A GeoDataFrame with a column describing displacement distances","title":"displacement()"}]}